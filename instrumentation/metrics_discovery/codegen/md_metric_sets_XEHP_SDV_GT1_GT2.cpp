/*========================== begin_copyright_notice ============================

Copyright (C) 2023 Intel Corporation

SPDX-License-Identifier: MIT

============================= end_copyright_notice ===========================*/

//     File Name:  md_metric_sets_XEHP_SDV_GT1_GT2.cpp
//
//     Abstract:   C++ automated generated file that defines Metric Sets
//                 for each Concurrent Group

#include "md_metric_sets_XEHP_SDV_GT1_GT2.h"
#include "md_metric_sets_XEHP_SDV_GT1.h"
#include "md_metric_sets_XEHP_SDV_GT2.h"
#include <algorithm>

#if MD_INCLUDE_XEHP_SDV_GT1_GT2_METRICS

namespace MetricsDiscoveryInternal::MetricSets_XEHP_SDV_GT1_GT2_PipelineStatistics
{
    CPipelineStatsMetricSet::CPipelineStatsMetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CPipelineStatsMetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "", 0, 0, 0x80000206, 0, 0, "", 0, "Intel_Raw_Pipeline_Statistics_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "IAVertices", "Input vertices",
                          "The total number of vertices that entered the 3D Pipeline.",
                          "3D Pipe/Input Assembler", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_IA * 0x10000 ), USAGE_FLAG_TIER_2 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_OGL | API_TYPE_OGL4_X,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "vertices", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "IAPrimitives", "Input primitives",
                          "The total number of rendering primitives assembled and put into the input assembly stage of the 3D Pipeline.",
                          "3D Pipe/Input Assembler", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_IA * 0x10000 ), USAGE_FLAG_TIER_2 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_OGL | API_TYPE_OGL4_X,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "triangles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "VsInvocations", "VS per vertex invocations",
                          "The total number of times a vertex shader was invoked. 3D rendering invokes the vertex shader once per vertex.",
                          "3D Pipe/Vertex Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_VS * 0x10000 ), USAGE_FLAG_TIER_2 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_OGL | API_TYPE_OGL4_X,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "invocations", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "HsInvocations", "HS invocations",
                          "The total number of times a hull shader was invoked.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_2 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_OGL | API_TYPE_OGL4_X,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "invocations", 0, 0, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x40" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "DsInvocations", "DS invocations",
                          "The total number of times a domain shader was invoked.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_2 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_OGL | API_TYPE_OGL4_X,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "invocations", 0, 0, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x48" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GsInvocations", "GS per triangle invocations",
                          "The total number of times a geometry shader was invoked per triangle.",
                          "3D Pipe/Geometry Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_GS * 0x10000 ), USAGE_FLAG_TIER_2 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_OGL | API_TYPE_OGL4_X,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "invocations", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x18" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GsPrimitives", "Post-GS primitives",
                          "The total number of primitives that flowed through from GS to the clipper if GS was enabled.",
                          "3D Pipe/Geometry Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_GS * 0x10000 ), USAGE_FLAG_TIER_2 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_OGL | API_TYPE_OGL4_X,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "triangles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x20" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "ClipperInvocations", "Clipper invocations",
                          "The total number of primitives sent to the Clipper.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_2 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_OGL | API_TYPE_OGL4_X,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "triangles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x28" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "ClipperPrimitives", "Clipper primitives",
                          "The total number of primitives that flowed out of the Clipper.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_2 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_OGL | API_TYPE_OGL4_X,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "triangles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x30" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PsInvocations", "PS invocations",
                          "The total number of times a pixel shader was invoked. 3D rendering invokes a pixel shader once per pixel or subsample.",
                          "3D Pipe/Pixel Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_PS * 0x10000 ), USAGE_FLAG_TIER_2 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_OGL | API_TYPE_OGL4_X,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "invocations", 0, 0, HW_UNIT_GPU, availabilityEquation, "Pixel|Fragment,PS|FS,pixel|fragment", nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x38" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "CsInvocations", "CS invocations",
                          "The total number of times a compute shader was invoked.",
                          "3D Pipe/Compute Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CS * 0x10000 ), USAGE_FLAG_TIER_2 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_OGL | API_TYPE_OGL4_X,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "invocations", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x50" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "CpsInvocations", "CPS invocations",
                          "The total number of times a coarse shader was invoked.",
                          "3D Pipe/Compute Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CS * 0x10000 ), USAGE_FLAG_TIER_2 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_OGL | API_TYPE_OGL4_X,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "invocations", 0, 0, HW_UNIT_GPU, availabilityEquation, "PS|FS", nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x58" ) ) );
        }

        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
} // namespace MetricsDiscoveryInternal::MetricSets_XEHP_SDV_GT1_GT2_PipelineStatistics

namespace MetricsDiscoveryInternal::MetricSets_XEHP_SDV_GT1_GT2_OA
{
    CHDCAndSF_Slice01MetricSet::CHDCAndSF_Slice01MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CHDCAndSF_Slice01MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice0";
        metric               = AddMetric( "NonSamplerShader00AccessStalledOnL3", "Slice0 Dualsubslice0 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice0 Dualsubslice0)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice1";
        metric               = AddMetric( "NonSamplerShader01AccessStalledOnL3", "Slice0 Dualsubslice1 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice0 Dualsubslice1)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice2";
        metric               = AddMetric( "NonSamplerShader02AccessStalledOnL3", "Slice0 Dualsubslice2 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice0 Dualsubslice2)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice3";
        metric               = AddMetric( "NonSamplerShader03AccessStalledOnL3", "Slice0 Dualsubslice3 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice0 Dualsubslice3)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice0";
        metric               = AddMetric( "NonSamplerShader10AccessStalledOnL3", "Slice1 Dualsubslice0 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice1 Dualsubslice0)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice1";
        metric               = AddMetric( "NonSamplerShader11AccessStalledOnL3", "Slice1 Dualsubslice1 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice1 Dualsubslice1)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice2";
        metric               = AddMetric( "NonSamplerShader12AccessStalledOnL3", "Slice1 Dualsubslice2 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice1 Dualsubslice2)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice3";
        metric               = AddMetric( "NonSamplerShader13AccessStalledOnL3", "Slice1 Dualsubslice3 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice1 Dualsubslice3)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20a34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20c34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20e34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21a34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21c34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21e34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08830025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac30025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ae30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e50040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d830025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01840100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0da30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fc30025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fe30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e44000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e54000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b00f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aa38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00070008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085597, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001900f2, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baa04, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01063800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01089700, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c1000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02030049, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c034800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e032752, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001200ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffe, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fffd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000fffb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000fff7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000ffef, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000ffdf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000ffbf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x0000ff7f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CHDCAndSF_Slice23MetricSet::CHDCAndSF_Slice23MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CHDCAndSF_Slice23MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice0";
        metric               = AddMetric( "NonSamplerShader20AccessStalledOnL3", "Slice2 Dualsubslice0 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice2 Dualsubslice0)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice1";
        metric               = AddMetric( "NonSamplerShader21AccessStalledOnL3", "Slice2 Dualsubslice1 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice2 Dualsubslice1)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice2";
        metric               = AddMetric( "NonSamplerShader22AccessStalledOnL3", "Slice2 Dualsubslice2 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice2 Dualsubslice2)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice3";
        metric               = AddMetric( "NonSamplerShader23AccessStalledOnL3", "Slice2 Dualsubslice3 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice2 Dualsubslice3)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice0";
        metric               = AddMetric( "NonSamplerShader30AccessStalledOnL3", "Slice3 Dualsubslice0 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice3 Dualsubslice0)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice1";
        metric               = AddMetric( "NonSamplerShader31AccessStalledOnL3", "Slice3 Dualsubslice1 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice3 Dualsubslice1)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice2";
        metric               = AddMetric( "NonSamplerShader32AccessStalledOnL3", "Slice3 Dualsubslice2 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice3 Dualsubslice2)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice3";
        metric               = AddMetric( "NonSamplerShader33AccessStalledOnL3", "Slice3 Dualsubslice3 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice3 Dualsubslice3)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000d, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21234000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20c34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20e34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21a34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21c34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21e34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08830025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07230000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09230940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01230000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac30025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ae30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e50040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d830025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01840100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0da30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fc30025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fe30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e44000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e54000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b00f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aa38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00070008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085597, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001900f2, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baa04, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01063800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01089700, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c1000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0002aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02030049, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c031800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030d06, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001200ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffe, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fffd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000fffb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000fff7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000ffef, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000ffdf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000ffbf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x0000ff7f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CHDCAndSF_Slice45MetricSet::CHDCAndSF_Slice45MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CHDCAndSF_Slice45MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice0";
        metric               = AddMetric( "NonSamplerShader40AccessStalledOnL3", "Slice4 Dualsubslice0 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice4 Dualsubslice0)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice1";
        metric               = AddMetric( "NonSamplerShader41AccessStalledOnL3", "Slice4 Dualsubslice1 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice4 Dualsubslice1)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice2";
        metric               = AddMetric( "NonSamplerShader42AccessStalledOnL3", "Slice4 Dualsubslice2 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice4 Dualsubslice2)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice3";
        metric               = AddMetric( "NonSamplerShader43AccessStalledOnL3", "Slice4 Dualsubslice3 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice4 Dualsubslice3)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice0";
        metric               = AddMetric( "NonSamplerShader50AccessStalledOnL3", "Slice5 Dualsubslice0 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice5 Dualsubslice0)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice1";
        metric               = AddMetric( "NonSamplerShader51AccessStalledOnL3", "Slice5 Dualsubslice1 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice5 Dualsubslice1)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice2";
        metric               = AddMetric( "NonSamplerShader52AccessStalledOnL3", "Slice5 Dualsubslice2 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice5 Dualsubslice2)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice3";
        metric               = AddMetric( "NonSamplerShader53AccessStalledOnL3", "Slice5 Dualsubslice3 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice5 Dualsubslice3)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20a34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20c34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20e34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21a34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21c34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21e34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08830025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac30025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ae30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e50040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d830025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01840100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0da30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fc30025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fe30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e44000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e54000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b00f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aa38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00070008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085597, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001900f2, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baa04, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01063800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01089700, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c1000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000400ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02030092, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c031800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030d06, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001200ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffe, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fffd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000fffb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000fff7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000ffef, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000ffdf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000ffbf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x0000ff7f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CHDCAndSF_Slice67MetricSet::CHDCAndSF_Slice67MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CHDCAndSF_Slice67MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice0";
        metric               = AddMetric( "NonSamplerShader60AccessStalledOnL3", "Slice6 Dualsubslice0 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice6 Dualsubslice0)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice1";
        metric               = AddMetric( "NonSamplerShader61AccessStalledOnL3", "Slice6 Dualsubslice1 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice6 Dualsubslice1)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice2";
        metric               = AddMetric( "NonSamplerShader62AccessStalledOnL3", "Slice6 Dualsubslice2 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice6 Dualsubslice2)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice3";
        metric               = AddMetric( "NonSamplerShader63AccessStalledOnL3", "Slice6 Dualsubslice3 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice6 Dualsubslice3)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice0";
        metric               = AddMetric( "NonSamplerShader70AccessStalledOnL3", "Slice7 Dualsubslice0 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice7 Dualsubslice0)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice1";
        metric               = AddMetric( "NonSamplerShader71AccessStalledOnL3", "Slice7 Dualsubslice1 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice7 Dualsubslice1)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice2";
        metric               = AddMetric( "NonSamplerShader72AccessStalledOnL3", "Slice7 Dualsubslice2 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice7 Dualsubslice2)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice3";
        metric               = AddMetric( "NonSamplerShader73AccessStalledOnL3", "Slice7 Dualsubslice3 Non-sampler Shader Access Stalled On L3",
                          "Percentage of time when HDC has messages to L3, but it's stalled due to lack of credits (Slice7 Dualsubslice3)",
                          "GPU/Data Port", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DATA_PORT * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20a34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20c34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x20e34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21a34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21c34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x21e34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08830025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac30025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ae30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e50040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d830025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01830000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01840100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0da30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fc30025, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fe30940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e30000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e44000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e54000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b00f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aa38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00070008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085597, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001900f2, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baa04, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01063800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01089700, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c1000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0001aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02030092, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c031800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030d06, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001200ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffe, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fffd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000fffb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000fff7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000ffef, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000ffdf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000ffbf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x0000ff7f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CHDCAndSF1MetricSet::CHDCAndSF1MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CHDCAndSF1MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Poly0DataReady", "Polygon (Slice0) Data Ready",
                          "The percentage of time in which geometry pipeline output is ready",
                          "GPU/3D Pipe/Strip-Fans", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Poly1DataReady", "Polygon (Slice1) Data Ready",
                          "The percentage of time in which geometry pipeline output is ready",
                          "GPU/3D Pipe/Strip-Fans", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Poly2DataReady", "Polygon (Slice2) Data Ready",
                          "The percentage of time in which geometry pipeline output is ready",
                          "GPU/3D Pipe/Strip-Fans", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Poly3DataReady", "Polygon (Slice3) Data Ready",
                          "The percentage of time in which geometry pipeline output is ready",
                          "GPU/3D Pipe/Strip-Fans", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Poly4DataReady", "Polygon (Slice4) Data Ready",
                          "The percentage of time in which geometry pipeline output is ready",
                          "GPU/3D Pipe/Strip-Fans", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Poly5DataReady", "Polygon (Slice5) Data Ready",
                          "The percentage of time in which geometry pipeline output is ready",
                          "GPU/3D Pipe/Strip-Fans", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Poly6DataReady", "Polygon (Slice6) Data Ready",
                          "The percentage of time in which geometry pipeline output is ready",
                          "GPU/3D Pipe/Strip-Fans", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Poly7DataReady", "Polygon (Slice7) Data Ready",
                          "The percentage of time in which geometry pipeline output is ready",
                          "GPU/3D Pipe/Strip-Fans", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GTRequestQueue00Full", "SQ00 is full",
                          "The percentage of time when IDI0 SQ00 is filled above a threshold (usually 48 entries)",
                          "GTI", ( METRIC_GROUP_NAME_ID_GTI * 0x1000000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GTRequestQueue10Full", "SQ10 is full",
                          "The percentage of time when IDI0 SQ10 is filled above a threshold (usually 48 entries)",
                          "GTI", ( METRIC_GROUP_NAME_ID_GTI * 0x1000000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GTRequestQueue20Full", "SQ20 is full",
                          "The percentage of time when IDI0 SQ20 is filled above a threshold (usually 48 entries)",
                          "GTI", ( METRIC_GROUP_NAME_ID_GTI * 0x1000000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GTRequestQueue30Full", "SQ30 is full",
                          "The percentage of time when IDI0 SQ30 is filled above a threshold (usually 48 entries)",
                          "GTI", ( METRIC_GROUP_NAME_ID_GTI * 0x1000000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GTRequestQueue40Full", "SQ40 is full",
                          "The percentage of time when IDI0 SQ40 is filled above a threshold (usually 48 entries)",
                          "GTI", ( METRIC_GROUP_NAME_ID_GTI * 0x1000000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GTRequestQueue50Full", "SQ50 is full",
                          "The percentage of time when IDI0 SQ50 is filled above a threshold (usually 48 entries)",
                          "GTI", ( METRIC_GROUP_NAME_ID_GTI * 0x1000000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GTRequestQueue60Full", "SQ60 is full",
                          "The percentage of time when IDI0 SQ60 is filled above a threshold (usually 48 entries)",
                          "GTI", ( METRIC_GROUP_NAME_ID_GTI * 0x1000000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GTRequestQueue70Full", "SQ70 is full",
                          "The percentage of time when IDI0 SQ70 is filled above a threshold (usually 48 entries)",
                          "GTI", ( METRIC_GROUP_NAME_ID_GTI * 0x1000000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d007000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d207000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d407000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d607000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d807000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0da07000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0dc07000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0de07000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020755aa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006f000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03000016, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17000006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03200016, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15200180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01208000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03400016, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15400006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0140d000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03600016, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13600180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0160c000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03800016, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13800006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01800700, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a00016, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11a00180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a00300, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c00016, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c00006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c00000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e00016, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fe00180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e00200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0001a500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00040030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000200a5, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02034892, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04034924, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48032a40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c0300e8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030784, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030839, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x520303c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54031029, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a03292b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12056400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13056400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0205001c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00080005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a0005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00190002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01050002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03050700, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01060004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01080004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000d, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12056400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13056400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b0008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04050007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060090, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00080050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00190008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01050002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050501c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01060040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01080040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a0040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12056400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13056400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b0020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06050007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060900, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00080500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00190020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01050002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x070501c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01060400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01080400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12056400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13056400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b0080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08050007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00069000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00190080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b8000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01050002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x090501c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01064000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01084000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00120003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001100a0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001300a0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00110a00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00120030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00130a00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011a000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001200c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013a000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffe, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fffd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000fffb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000fff7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000ffef, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000ffdf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000ffbf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x0000ff7f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CL3_Slice01MetricSet::CL3_Slice01MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CL3_Slice01MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank00InputAvailable", "L3Bank00 Input Available",
                          "The percentage of time when L3Bank00 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank01InputAvailable", "L3Bank01 Input Available",
                          "The percentage of time when L3Bank01 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank02InputAvailable", "L3Bank02 Input Available",
                          "The percentage of time when L3Bank02 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank03InputAvailable", "L3Bank03 Input Available",
                          "The percentage of time when L3Bank03 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank04InputAvailable", "L3Bank04 Input Available",
                          "The percentage of time when L3Bank04 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank05InputAvailable", "L3Bank05 Input Available",
                          "The percentage of time when L3Bank05 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank06InputAvailable", "L3Bank06 Input Available",
                          "The percentage of time when L3Bank06 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank07InputAvailable", "L3Bank07 Input Available",
                          "The percentage of time when L3Bank07 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank00OutputReady", "L3Bank00 Output Ready",
                          "The percentage of time when L3Bank00 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank01OutputReady", "L3Bank01 Output Ready",
                          "The percentage of time when L3Bank01 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank02OutputReady", "L3Bank02 Output Ready",
                          "The percentage of time when L3Bank02 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank03OutputReady", "L3Bank03 Output Ready",
                          "The percentage of time when L3Bank03 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank04OutputReady", "L3Bank04 Output Ready",
                          "The percentage of time when L3Bank04 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank05OutputReady", "L3Bank05 Output Ready",
                          "The percentage of time when L3Bank05 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank06OutputReady", "L3Bank06 Output Ready",
                          "The percentage of time when L3Bank06 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank07OutputReady", "L3Bank07 Output Ready",
                          "The percentage of time when L3Bank07 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x032e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x034e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x036e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x038e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03ae2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03ce2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03ee2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00135555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02135555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b0e0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x130e01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x012e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b2e0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x132e0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x014e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x094e0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x114e01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x016e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x096e0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x116e0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x018e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x078e0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f8e01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01ae0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07ae0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fae0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01ce0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05ce0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0dce01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01ee0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05ee0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0dee0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00040091, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02040091, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050059, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050059, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060021, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02060021, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00070101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00084492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02082459, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04083312, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06080001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00098400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02098400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a4400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a4400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b2020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030c44, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e031041, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030801, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030600, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030482, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CL3_Slice23MetricSet::CL3_Slice23MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CL3_Slice23MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank10InputAvailable", "L3Bank10 Input Available",
                          "The percentage of time when L3Bank10 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank11InputAvailable", "L3Bank11 Input Available",
                          "The percentage of time when L3Bank11 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank12InputAvailable", "L3Bank12 Input Available",
                          "The percentage of time when L3Bank12 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank13InputAvailable", "L3Bank13 Input Available",
                          "The percentage of time when L3Bank13 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank14InputAvailable", "L3Bank14 Input Available",
                          "The percentage of time when L3Bank14 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank15InputAvailable", "L3Bank15 Input Available",
                          "The percentage of time when L3Bank15 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank16InputAvailable", "L3Bank16 Input Available",
                          "The percentage of time when L3Bank16 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank17InputAvailable", "L3Bank17 Input Available",
                          "The percentage of time when L3Bank17 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank10OutputReady", "L3Bank10 Output Ready",
                          "The percentage of time when L3Bank10 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank11OutputReady", "L3Bank11 Output Ready",
                          "The percentage of time when L3Bank11 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank12OutputReady", "L3Bank12 Output Ready",
                          "The percentage of time when L3Bank12 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank13OutputReady", "L3Bank13 Output Ready",
                          "The percentage of time when L3Bank13 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank14OutputReady", "L3Bank14 Output Ready",
                          "The percentage of time when L3Bank14 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank15OutputReady", "L3Bank15 Output Ready",
                          "The percentage of time when L3Bank15 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank16OutputReady", "L3Bank16 Output Ready",
                          "The percentage of time when L3Bank16 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank17OutputReady", "L3Bank17 Output Ready",
                          "The percentage of time when L3Bank17 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x032e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x034e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x036e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x038e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03ae2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03ce2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03ee2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00135555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02135555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b0e0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x130e01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x012e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b2e0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x132e0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x014e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x094e0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x114e01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x016e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x096e0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x116e0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x018e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x078e0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f8e01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01ae0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07ae0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fae0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01ce0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05ce0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0dce01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01ee0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05ee0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0dee0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00040091, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02040091, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050059, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050059, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060021, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02060021, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00070101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00084492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02082459, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04083312, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06080001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00098400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02098400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a4400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a4400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b2020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0002aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0202aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030c44, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e031041, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030801, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030600, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030482, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CL3_Slice45MetricSet::CL3_Slice45MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CL3_Slice45MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank20InputAvailable", "L3Bank20 Input Available",
                          "The percentage of time when L3Bank20 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank21InputAvailable", "L3Bank21 Input Available",
                          "The percentage of time when L3Bank21 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank22InputAvailable", "L3Bank22 Input Available",
                          "The percentage of time when L3Bank22 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank23InputAvailable", "L3Bank23 Input Available",
                          "The percentage of time when L3Bank23 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank24InputAvailable", "L3Bank24 Input Available",
                          "The percentage of time when L3Bank24 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank25InputAvailable", "L3Bank25 Input Available",
                          "The percentage of time when L3Bank25 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank26InputAvailable", "L3Bank26 Input Available",
                          "The percentage of time when L3Bank26 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank27InputAvailable", "L3Bank27 Input Available",
                          "The percentage of time when L3Bank27 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank20OutputReady", "L3Bank20 Output Ready",
                          "The percentage of time when L3Bank20 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank21OutputReady", "L3Bank21 Output Ready",
                          "The percentage of time when L3Bank21 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank22OutputReady", "L3Bank22 Output Ready",
                          "The percentage of time when L3Bank22 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank23OutputReady", "L3Bank23 Output Ready",
                          "The percentage of time when L3Bank23 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank24OutputReady", "L3Bank24 Output Ready",
                          "The percentage of time when L3Bank24 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank25OutputReady", "L3Bank25 Output Ready",
                          "The percentage of time when L3Bank25 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank26OutputReady", "L3Bank26 Output Ready",
                          "The percentage of time when L3Bank26 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank27OutputReady", "L3Bank27 Output Ready",
                          "The percentage of time when L3Bank27 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x032e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x034e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x036e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x038e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03ae2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03ce2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03ee2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00135555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02135555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b0e0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x130e01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x012e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b2e0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x132e0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x014e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x094e0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x114e01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x016e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x096e0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x116e0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x018e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x078e0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f8e01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01ae0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07ae0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fae0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01ce0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05ce0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0dce01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01ee0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05ee0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0dee0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00040091, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02040091, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050059, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050059, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060021, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02060021, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00070101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00084492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02082459, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04083312, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06080001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00098400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02098400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a4400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a4400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b2020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0004ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030c44, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e031041, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030801, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030600, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030482, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CL3_Slice67MetricSet::CL3_Slice67MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CL3_Slice67MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank30InputAvailable", "L3Bank30 Input Available",
                          "The percentage of time when L3Bank30 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank31InputAvailable", "L3Bank31 Input Available",
                          "The percentage of time when L3Bank31 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank32InputAvailable", "L3Bank32 Input Available",
                          "The percentage of time when L3Bank32 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank33InputAvailable", "L3Bank33 Input Available",
                          "The percentage of time when L3Bank33 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank34InputAvailable", "L3Bank34 Input Available",
                          "The percentage of time when L3Bank34 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank35InputAvailable", "L3Bank35 Input Available",
                          "The percentage of time when L3Bank35 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank36InputAvailable", "L3Bank36 Input Available",
                          "The percentage of time when L3Bank36 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank37InputAvailable", "L3Bank37 Input Available",
                          "The percentage of time when L3Bank37 has input available",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank30OutputReady", "L3Bank30 Output Ready",
                          "The percentage of time when L3Bank30 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank31OutputReady", "L3Bank31 Output Ready",
                          "The percentage of time when L3Bank31 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank32OutputReady", "L3Bank32 Output Ready",
                          "The percentage of time when L3Bank32 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank33OutputReady", "L3Bank33 Output Ready",
                          "The percentage of time when L3Bank33 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank34OutputReady", "L3Bank34 Output Ready",
                          "The percentage of time when L3Bank34 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank35OutputReady", "L3Bank35 Output Ready",
                          "The percentage of time when L3Bank35 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank36OutputReady", "L3Bank36 Output Ready",
                          "The percentage of time when L3Bank36 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "L3Bank37OutputReady", "L3Bank37 Output Ready",
                          "The percentage of time when L3Bank37 output is ready",
                          "GPU/L3", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_L3 * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE_BANK, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x032e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x034e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x036e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x038e2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03ae2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03ce2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03ee2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00135555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02135555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b0e0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x130e01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x012e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b2e0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x132e0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x014e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x094e0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x114e01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x016e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x096e0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x116e0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x018e0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x078e0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f8e01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01ae0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07ae0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fae0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01ce0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05ce0180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0dce01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01ee0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05ee0006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0dee0007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00040091, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02040091, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050059, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050059, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060021, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02060021, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00070101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00084492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02082459, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04083312, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06080001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00098400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02098400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a4400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a4400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b2020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0001aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0201aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030c44, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e031041, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030801, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030600, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030482, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CRasterizerAndPixelBackend1MetricSet::CRasterizerAndPixelBackend1MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CRasterizerAndPixelBackend1MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0";
        metric               = AddMetric( "Rasterizer0InputAvailable", "Slice0 Rasterizer Input Available",
                          "The percentage of time in which slice0 rasterizer input is available",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1";
        metric               = AddMetric( "Rasterizer1OutputReady", "Slice1 Rasterizer Output Ready",
                          "The percentage of time in which slice1 rasterizer output is ready",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData00Ready", "Slice0 Pipe0 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice0  pipe0 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData01Ready", "Slice0 Pipe1 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice0  pipe1 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2";
        metric               = AddMetric( "Rasterizer2InputAvailable", "Slice2 Rasterizer Input Available",
                          "The percentage of time in which slice2 rasterizer input is available",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3";
        metric               = AddMetric( "Rasterizer3OutputReady", "Slice3 Rasterizer Output Ready",
                          "The percentage of time in which slice3 rasterizer output is ready",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData20Ready", "Slice2 Pipe0 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice2  pipe0 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData21Ready", "Slice2 Pipe1 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice2  pipe1 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a056000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x080b7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a0b600f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x080c7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a0c6000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1b057000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b8000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020535d2, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0405003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00063e95, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02068000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00081555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02084000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a1555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00198018, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040b002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x060b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b8000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040c002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0c0c000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x060c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11050dc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03064000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03084000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000d, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a056000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x080b7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a0b6000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x080c7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a0c6000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1b057000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08050d00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a050fb5, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00064000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02062fa5, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00084000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02081555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a1555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00194c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040b002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x100b03c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x060b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a3000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040c002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x120c03c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x060c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11050037, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03061000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03081000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a1000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00029555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02026aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030a40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c03481c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e033192, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x5003180c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030241, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030824, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030842, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00112aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02118000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012807f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00132aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02138000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00118000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02112aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00127f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00138000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02132aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x30800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000038, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fff8, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x000000c0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000ffe7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000300, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000ff9f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00001c00, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000fc7f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00006000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000f3ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00018000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000cfff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CRasterizerAndPixelBackend2MetricSet::CRasterizerAndPixelBackend2MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CRasterizerAndPixelBackend2MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1";
        metric               = AddMetric( "Rasterizer1InputAvailable", "Slice1 Rasterizer Input Available",
                          "The percentage of time in which slice1 rasterizer input is available",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0";
        metric               = AddMetric( "Rasterizer0OutputReady", "Slice0 Rasterizer Output Ready",
                          "The percentage of time in which slice0 rasterizer output is ready",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData10Ready", "Slice1 Pipe0 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice1  pipe0 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData11Ready", "Slice1 Pipe1 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice1  pipe1 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3";
        metric               = AddMetric( "Rasterizer3InputAvailable", "Slice3 Rasterizer Input Available",
                          "The percentage of time in which slice3 rasterizer input is available",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2";
        metric               = AddMetric( "Rasterizer2OutputReady", "Slice2 Rasterizer Output Ready",
                          "The percentage of time in which slice2 rasterizer output is ready",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData30Ready", "Slice3 Pipe0 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice3  pipe0 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData31Ready", "Slice3 Pipe1 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice3  pipe1 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a057000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1b056000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1d050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x090b7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b0b600f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x090c7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b0c6000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b007f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10050dc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00062aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02064000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00081555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02084000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a1555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019007f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b2aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030535d2, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0505003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01063e95, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01081555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a1555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190018, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050b002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x070b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050c002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d0c000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x070c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000d, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a057000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1b056000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1d050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x090b7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b0b6000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x090c7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b0c6000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b3f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10050037, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00068000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02061aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00084000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02081555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a1555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00193f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b8000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b0aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03050002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09050d00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b050fb5, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01064000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03060fa5, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01084000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03080555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a0555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050b002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x110b03c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x070b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a3000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050c002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x130c03c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x070c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00029555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02026aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x480308c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c031b0a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030241, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030824, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030842, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00112aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02118000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012807f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00132aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02138000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00118000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02112aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00127f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00138000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02132aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x30800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000038, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fff8, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x000000c0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000ffe7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000300, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000ff9f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00001c00, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000fc7f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00006000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000f3ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00018000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000cfff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CRasterizerAndPixelBackend3MetricSet::CRasterizerAndPixelBackend3MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CRasterizerAndPixelBackend3MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4";
        metric               = AddMetric( "Rasterizer4InputAvailable", "Slice4 Rasterizer Input Available",
                          "The percentage of time in which slice4 rasterizer input is available",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5";
        metric               = AddMetric( "Rasterizer5OutputReady", "Slice5 Rasterizer Output Ready",
                          "The percentage of time in which slice5 rasterizer output is ready",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData40Ready", "Slice4 Pipe0 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice4  pipe0 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData41Ready", "Slice4 Pipe1 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice4  pipe1 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6";
        metric               = AddMetric( "Rasterizer6InputAvailable", "Slice6 Rasterizer Input Available",
                          "The percentage of time in which slice6 rasterizer input is available",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7";
        metric               = AddMetric( "Rasterizer7OutputReady", "Slice7 Rasterizer Output Ready",
                          "The percentage of time in which slice7 rasterizer output is ready",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData60Ready", "Slice6 Pipe0 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice6  pipe0 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData61Ready", "Slice6 Pipe1 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice6  pipe1 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a056000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x080b7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a0b600f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x080c7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a0c6000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1b057000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b8000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020535d2, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0405003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00063e95, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02068000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00081555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02084000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a1555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00198018, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040b002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x060b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b8000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040c002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0c0c000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x060c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11050dc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03064000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03084000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a056000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x080b7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a0b6000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x080c7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a0c6000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1b057000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08050d00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a050fb5, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00064000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02062fa5, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00084000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02081555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a1555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00194c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040b002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x100b03c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x060b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a3000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040c002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x120c03c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x060c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11050037, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03061000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03081000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a1000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00019555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02016aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0004807f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48031cc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c031803, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e031086, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030804, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030090, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54031209, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a031ce7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00112aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02118000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012807f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00132aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02138000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00118000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02112aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00127f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00138000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02132aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x30800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000038, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fff8, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x000000c0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000ffe7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000300, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000ff9f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00001c00, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000fc7f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00006000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000f3ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00018000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000cfff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CRasterizerAndPixelBackend4MetricSet::CRasterizerAndPixelBackend4MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CRasterizerAndPixelBackend4MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5";
        metric               = AddMetric( "Rasterizer5InputAvailable", "Slice5 Rasterizer Input Available",
                          "The percentage of time in which slice5 rasterizer input is available",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4";
        metric               = AddMetric( "Rasterizer4OutputReady", "Slice4 Rasterizer Output Ready",
                          "The percentage of time in which slice4 rasterizer output is ready",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData50Ready", "Slice5 Pipe0 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice5  pipe0 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData51Ready", "Slice5 Pipe1 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice5  pipe1 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7";
        metric               = AddMetric( "Rasterizer7InputAvailable", "Slice7 Rasterizer Input Available",
                          "The percentage of time in which slice7 rasterizer input is available",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6";
        metric               = AddMetric( "Rasterizer6OutputReady", "Slice6 Rasterizer Output Ready",
                          "The percentage of time in which slice6 rasterizer output is ready",
                          "GPU/Rasterizer", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData70Ready", "Slice7 Pipe0 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice7  pipe0 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelData71Ready", "Slice7 Pipe1 Post-EarlyZ Pixel Data Ready",
                          "The percentage of time in which slice7  pipe1 post-EarlyZ pixel data is ready (after early Z tests have been applied)",
                          "GPU/Rasterizer/Early Depth Test", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_IZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a057000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1b056000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1d050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x090b7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b0b600f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x090c7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b0c6000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b007f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10050dc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00062aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02064000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00081555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02084000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a1555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019007f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b2aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030535d2, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0505003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01063e95, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01081555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a1555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190018, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050b002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x070b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050c002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d0c000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x070c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a057000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1b056000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1d050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x090b7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b0b6000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x090c7000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b0c6000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b3f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10050037, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00068000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02061aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00084000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02081555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a1555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00193f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b8000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b0aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01050000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03050002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09050d00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b050fb5, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01064000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03060fa5, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01084000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03080555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a0555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050b002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x110b03c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x070b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a3000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050c002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x130c03c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x070c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00019555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02016aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0004807f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c03090b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030a05, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030c63, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00112aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02118000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012807f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00132aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02138000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00118000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02112aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00127f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00138000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02132aaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x30800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000038, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fff8, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x000000c0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000ffe7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000300, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000ff9f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00001c00, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000fc7f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00006000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000f3ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00018000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000cfff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CRasterizerAndPixelBackend5MetricSet::CRasterizerAndPixelBackend5MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CRasterizerAndPixelBackend5MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PSOutput00Available", "PS00 Output Available",
                          "The percentage of time in which PS00 output is available",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "PS|FS", nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PSOutput01Available", "PS01 Output Available",
                          "The percentage of time in which PS01 output is available",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "PS|FS", nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PSOutput10Available", "PS10 Output Available",
                          "The percentage of time in which PS10 output is available",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "PS|FS", nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PSOutput11Available", "PS11 Output Available",
                          "The percentage of time in which PS11 output is available",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "PS|FS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PSOutput20Available", "PS20 Output Available",
                          "The percentage of time in which PS20 output is available",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "PS|FS", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PSOutput21Available", "PS21 Output Available",
                          "The percentage of time in which PS21 output is available",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "PS|FS", nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PSOutput30Available", "PS30 Output Available",
                          "The percentage of time in which PS30 output is available",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "PS|FS", nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PSOutput31Available", "PS31 Output Available",
                          "The percentage of time in which PS31 output is available",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "PS|FS", nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelValues00Ready", "Pixel Values 00 Ready",
                          "The percentage of time in which pixel values 00 are ready",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelValues01Ready", "Pixel Values 01 Ready",
                          "The percentage of time in which pixel values 01 are ready",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelValues10Ready", "Pixel Values 10 Ready",
                          "The percentage of time in which pixel values 10 are ready",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelValues11Ready", "Pixel Values 11 Ready",
                          "The percentage of time in which pixel values 11 are ready",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelValues20Ready", "Pixel Values 20 Ready",
                          "The percentage of time in which pixel values 20 are ready",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelValues21Ready", "Pixel Values 21 Ready",
                          "The percentage of time in which pixel values 21 are ready",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelValues30Ready", "Pixel Values 30 Ready",
                          "The percentage of time in which pixel values 30 are ready",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "PixelValues31Ready", "Pixel Values 31 Ready",
                          "The percentage of time in which pixel values 31 are ready",
                          "GPU/3D Pipe", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SLICE, availabilityEquation, "Pixel|Fragment,pixel|fragment", nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18060126, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x160b0126, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00135000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02135000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00041000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02041000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00051000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02051000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a060031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12060038, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04060000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02060000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02080050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04082000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06080001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00094000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02094000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a4000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x080b0c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x100b0e00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18060126, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x160b0126, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00130500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02130500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00040100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02040100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08060031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10060038, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04060000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02060000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00082000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02080001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04080280, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00090400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02090400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x060b0c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e0b0e00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18060126, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x160b0126, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00130050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02130050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00040010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02040010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06060031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e060038, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04060000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02060000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00080280, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0408000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00090040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02090040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a0040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a0040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040b0c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0c0b0e00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18060126, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x160b0126, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00130005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02130005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00040001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02040001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00050001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02050001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04060031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0c060038, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02060000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02081400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00090004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02090004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b0c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a0b0e00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0001005a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0201005a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00040c0c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00025a00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02025a00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032449, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031252, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030c21, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030203, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030603, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030c60, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CRenderPipeProfile_Slice0MetricSet::CRenderPipeProfile_Slice0MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CRenderPipeProfile_Slice0MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vf0Bottleneck", "VF0 Bottleneck",
                          "The percentage of time in which vertex fetch pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Input Assembler", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_IA * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vs0Bottleneck", "VS0 Bottleneck",
                          "The percentage of time in which VS0 pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Vertex Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_VS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl0Bottleneck", "Clipper0 Bottleneck",
                          "The percentage of time in which clipper pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs0Bottleneck", "HS0 Bottleneck",
                          "The percentage of time in which hull shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 3, 9, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds0Bottleneck", "DS0 Bottleneck",
                          "The percentage of time in which domain shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Gs0Bottleneck", "GS0 Bottleneck",
                          "The percentage of time in which geometry shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Geometry Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_GS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf0Bottleneck", "SF0 Bottleneck",
                          "The percentage of time in which strip-fans pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 10, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So0Bottleneck", "SO0 Bottleneck",
                          "The percentage of time in which stream output pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl0Stall", "CL0 Stall",
                          "The percentage of time in which clipper pipeline stage was stalled.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs0Stall", "HS0 Stall",
                          "The percentage of time in which hull stall pipeline stage was stalled.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds0Stall", "DS0 Stall",
                          "The percentage of time in which domain shader pipeline stage was stalled.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf0Stall", "SF0 Stall",
                          "The percentage of time in which strip-fans pipeline stage was stalled.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So0Stall", "SO0 Stall",
                          "The percentage of time in which stream-output pipeline stage was stalled.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hi0DepthBottleneck", "Hi0Depth Bottleneck",
                          "The percentage of time in which early hierarchical depth test pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Hi-Depth Test", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_HZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Bc0Bottleneck", "BC0 Bottleneck",
                          "The percentage of time in which barycentric coordinates calculation pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Barycentric Calc", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_BC * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x168507c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x161b001f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0c1b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x141c0019, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x061c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14090000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a0903c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x160a01f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x160b7c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08850002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x021b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x041b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a1b01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x101b00c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x121b0c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001c0600, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x081c0440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e1c0482, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00062c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020622f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0407000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08070840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e070023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008149c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02081152, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00094003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06090880, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a090001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0c090023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10090003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040a0200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x140a0940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a9654, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a1959, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00195044, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x080b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x060b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b2200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c00a0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00025554, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031248, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c032de0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e033d63, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x520300f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54031e0b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a033c01, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012fffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CRenderPipeProfile_Slice1MetricSet::CRenderPipeProfile_Slice1MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CRenderPipeProfile_Slice1MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vf1Bottleneck", "VF1 Bottleneck",
                          "The percentage of time in which vertex fetch pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Input Assembler", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_IA * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vs1Bottleneck", "VS1 Bottleneck",
                          "The percentage of time in which VS1 pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Vertex Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_VS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl1Bottleneck", "Clipper1 Bottleneck",
                          "The percentage of time in which clipper pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs1Bottleneck", "HS1 Bottleneck",
                          "The percentage of time in which hull shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 3, 9, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds1Bottleneck", "DS1 Bottleneck",
                          "The percentage of time in which domain shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Gs1Bottleneck", "GS1 Bottleneck",
                          "The percentage of time in which geometry shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Geometry Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_GS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf1Bottleneck", "SF1 Bottleneck",
                          "The percentage of time in which strip-fans pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 10, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So1Bottleneck", "SO1 Bottleneck",
                          "The percentage of time in which stream output pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl1Stall", "CL1 Stall",
                          "The percentage of time in which clipper pipeline stage was stalled.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs1Stall", "HS1 Stall",
                          "The percentage of time in which hull stall pipeline stage was stalled.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds1Stall", "DS1 Stall",
                          "The percentage of time in which domain shader pipeline stage was stalled.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf1Stall", "SF1 Stall",
                          "The percentage of time in which strip-fans pipeline stage was stalled.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So1Stall", "SO1 Stall",
                          "The percentage of time in which stream-output pipeline stage was stalled.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hi1DepthBottleneck", "Hi1Depth Bottleneck",
                          "The percentage of time in which early hierarchical depth test pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Hi-Depth Test", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_HZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Bc1Bottleneck", "BC1 Bottleneck",
                          "The percentage of time in which barycentric coordinates calculation pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Barycentric Calc", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_BC * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x178507c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x171b001f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d1b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x151c0019, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x071c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x25070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15090000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1b0903c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x170a01f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x170b7c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09850002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bfffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085554, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5554, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019fffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x031b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x051b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b1b01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x111b00c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x131b0c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011c0600, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x091c0440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f1c0482, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01062c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030622f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0507000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09070840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f070023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0108149c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03081152, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01094003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07090880, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b090001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d090023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11090003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050a0200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x150a0940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a9654, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a1959, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01195044, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x090b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x070b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b2200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c0800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c00a0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00025554, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031248, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c032de0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e033d63, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x520300f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54031e0b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a033c01, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012fffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CRenderPipeProfile_Slice2MetricSet::CRenderPipeProfile_Slice2MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CRenderPipeProfile_Slice2MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vf2Bottleneck", "VF2 Bottleneck",
                          "The percentage of time in which vertex fetch pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Input Assembler", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_IA * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vs2Bottleneck", "VS2 Bottleneck",
                          "The percentage of time in which VS2 pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Vertex Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_VS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl2Bottleneck", "Clipper2 Bottleneck",
                          "The percentage of time in which clipper pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs2Bottleneck", "HS2 Bottleneck",
                          "The percentage of time in which hull shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 3, 9, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds2Bottleneck", "DS2 Bottleneck",
                          "The percentage of time in which domain shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Gs2Bottleneck", "GS2 Bottleneck",
                          "The percentage of time in which geometry shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Geometry Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_GS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf2Bottleneck", "SF2 Bottleneck",
                          "The percentage of time in which strip-fans pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 10, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So2Bottleneck", "SO2 Bottleneck",
                          "The percentage of time in which stream output pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl2Stall", "CL2 Stall",
                          "The percentage of time in which clipper pipeline stage was stalled.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs2Stall", "HS2 Stall",
                          "The percentage of time in which hull stall pipeline stage was stalled.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds2Stall", "DS2 Stall",
                          "The percentage of time in which domain shader pipeline stage was stalled.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf2Stall", "SF2 Stall",
                          "The percentage of time in which strip-fans pipeline stage was stalled.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So2Stall", "SO2 Stall",
                          "The percentage of time in which stream-output pipeline stage was stalled.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hi2DepthBottleneck", "Hi2Depth Bottleneck",
                          "The percentage of time in which early hierarchical depth test pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Hi-Depth Test", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_HZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Bc2Bottleneck", "BC2 Bottleneck",
                          "The percentage of time in which barycentric coordinates calculation pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Barycentric Calc", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_BC * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000d, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x168507c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x161b001f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0c1b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x141c0019, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x061c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14090000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a0903c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x160a01f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x160b7c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08850002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x021b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x041b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a1b01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x101b00c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x121b0c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001c0600, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x081c0440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e1c0482, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00062c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020622f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0407000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08070840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e070023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008149c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02081152, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00094003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06090880, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a090001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0c090023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10090003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040a0200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x140a0940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a9654, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a1959, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00195044, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x080b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x060b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b2200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c00a0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0002aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0202aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031248, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030ca0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e031461, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030a03, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a031401, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012fffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CRenderPipeProfile_Slice3MetricSet::CRenderPipeProfile_Slice3MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CRenderPipeProfile_Slice3MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vf3Bottleneck", "VF3 Bottleneck",
                          "The percentage of time in which vertex fetch pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Input Assembler", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_IA * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vs3Bottleneck", "VS3 Bottleneck",
                          "The percentage of time in which VS3 pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Vertex Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_VS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl3Bottleneck", "Clipper3 Bottleneck",
                          "The percentage of time in which clipper pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs3Bottleneck", "HS3 Bottleneck",
                          "The percentage of time in which hull shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 3, 9, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds3Bottleneck", "DS3 Bottleneck",
                          "The percentage of time in which domain shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Gs3Bottleneck", "GS3 Bottleneck",
                          "The percentage of time in which geometry shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Geometry Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_GS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf3Bottleneck", "SF3 Bottleneck",
                          "The percentage of time in which strip-fans pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 10, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So3Bottleneck", "SO3 Bottleneck",
                          "The percentage of time in which stream output pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl3Stall", "CL3 Stall",
                          "The percentage of time in which clipper pipeline stage was stalled.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs3Stall", "HS3 Stall",
                          "The percentage of time in which hull stall pipeline stage was stalled.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds3Stall", "DS3 Stall",
                          "The percentage of time in which domain shader pipeline stage was stalled.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf3Stall", "SF3 Stall",
                          "The percentage of time in which strip-fans pipeline stage was stalled.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So3Stall", "SO3 Stall",
                          "The percentage of time in which stream-output pipeline stage was stalled.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hi3DepthBottleneck", "Hi3Depth Bottleneck",
                          "The percentage of time in which early hierarchical depth test pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Hi-Depth Test", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_HZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Bc3Bottleneck", "BC3 Bottleneck",
                          "The percentage of time in which barycentric coordinates calculation pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Barycentric Calc", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_BC * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000d, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x178507c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x171b001f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d1b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x151c0019, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x071c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x25070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15090000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1b0903c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x170a01f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x170b7c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09850002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bfffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085554, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5554, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019fffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x031b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x051b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b1b01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x111b00c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x131b0c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011c0600, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x091c0440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f1c0482, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01062c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030622f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0507000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09070840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f070023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0108149c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03081152, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01094003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07090880, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b090001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d090023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11090003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050a0200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x150a0940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a9654, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a1959, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01195044, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x090b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x070b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b2200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c0800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c00a0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0002aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0202aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031248, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030ca0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e031461, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030a03, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a031401, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012fffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CRenderPipeProfile_Slice4MetricSet::CRenderPipeProfile_Slice4MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CRenderPipeProfile_Slice4MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vf4Bottleneck", "VF4 Bottleneck",
                          "The percentage of time in which vertex fetch pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Input Assembler", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_IA * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vs4Bottleneck", "VS4 Bottleneck",
                          "The percentage of time in which VS4 pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Vertex Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_VS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl4Bottleneck", "Clipper4 Bottleneck",
                          "The percentage of time in which clipper pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs4Bottleneck", "HS4 Bottleneck",
                          "The percentage of time in which hull shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 3, 9, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds4Bottleneck", "DS4 Bottleneck",
                          "The percentage of time in which domain shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Gs4Bottleneck", "GS4 Bottleneck",
                          "The percentage of time in which geometry shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Geometry Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_GS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf4Bottleneck", "SF4 Bottleneck",
                          "The percentage of time in which strip-fans pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 10, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So4Bottleneck", "SO4 Bottleneck",
                          "The percentage of time in which stream output pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl4Stall", "CL4 Stall",
                          "The percentage of time in which clipper pipeline stage was stalled.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs4Stall", "HS4 Stall",
                          "The percentage of time in which hull stall pipeline stage was stalled.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds4Stall", "DS4 Stall",
                          "The percentage of time in which domain shader pipeline stage was stalled.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf4Stall", "SF4 Stall",
                          "The percentage of time in which strip-fans pipeline stage was stalled.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So4Stall", "SO4 Stall",
                          "The percentage of time in which stream-output pipeline stage was stalled.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hi4DepthBottleneck", "Hi4Depth Bottleneck",
                          "The percentage of time in which early hierarchical depth test pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Hi-Depth Test", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_HZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Bc4Bottleneck", "BC4 Bottleneck",
                          "The percentage of time in which barycentric coordinates calculation pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Barycentric Calc", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_BC * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x168507c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x161b001f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0c1b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x141c0019, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x061c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14090000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a0903c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x160a01f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x160b7c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08850002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x021b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x041b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a1b01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x101b00c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x121b0c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001c0600, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x081c0440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e1c0482, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00062c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020622f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0407000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08070840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e070023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008149c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02081152, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00094003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06090880, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a090001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0c090023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10090003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040a0200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x140a0940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a9654, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a1959, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00195044, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x080b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x060b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b2200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c00a0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00015554, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0004fffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032490, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030ca0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e031461, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030a03, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a031401, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012fffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CRenderPipeProfile_Slice5MetricSet::CRenderPipeProfile_Slice5MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CRenderPipeProfile_Slice5MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vf5Bottleneck", "VF5 Bottleneck",
                          "The percentage of time in which vertex fetch pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Input Assembler", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_IA * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vs5Bottleneck", "VS5 Bottleneck",
                          "The percentage of time in which VS5 pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Vertex Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_VS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl5Bottleneck", "Clipper5 Bottleneck",
                          "The percentage of time in which clipper pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs5Bottleneck", "HS5 Bottleneck",
                          "The percentage of time in which hull shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 3, 9, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds5Bottleneck", "DS5 Bottleneck",
                          "The percentage of time in which domain shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Gs5Bottleneck", "GS5 Bottleneck",
                          "The percentage of time in which geometry shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Geometry Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_GS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf5Bottleneck", "SF5 Bottleneck",
                          "The percentage of time in which strip-fans pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 10, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So5Bottleneck", "SO5 Bottleneck",
                          "The percentage of time in which stream output pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl5Stall", "CL5 Stall",
                          "The percentage of time in which clipper pipeline stage was stalled.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs5Stall", "HS5 Stall",
                          "The percentage of time in which hull stall pipeline stage was stalled.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds5Stall", "DS5 Stall",
                          "The percentage of time in which domain shader pipeline stage was stalled.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf5Stall", "SF5 Stall",
                          "The percentage of time in which strip-fans pipeline stage was stalled.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So5Stall", "SO5 Stall",
                          "The percentage of time in which stream-output pipeline stage was stalled.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hi5DepthBottleneck", "Hi5Depth Bottleneck",
                          "The percentage of time in which early hierarchical depth test pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Hi-Depth Test", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_HZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Bc5Bottleneck", "BC5 Bottleneck",
                          "The percentage of time in which barycentric coordinates calculation pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Barycentric Calc", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_BC * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x178507c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x171b001f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d1b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x151c0019, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x071c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x25070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15090000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1b0903c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x170a01f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x170b7c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09850002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bfffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085554, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5554, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019fffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x031b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x051b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b1b01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x111b00c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x131b0c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011c0600, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x091c0440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f1c0482, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01062c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030622f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0507000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09070840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f070023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0108149c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03081152, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01094003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07090880, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b090001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d090023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11090003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050a0200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x150a0940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a9654, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a1959, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01195044, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x090b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x070b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b2200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c0800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c00a0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00015554, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0004fffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032490, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030ca0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e031461, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030a03, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a031401, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012fffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CRenderPipeProfile_Slice6MetricSet::CRenderPipeProfile_Slice6MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CRenderPipeProfile_Slice6MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vf6Bottleneck", "VF6 Bottleneck",
                          "The percentage of time in which vertex fetch pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Input Assembler", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_IA * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vs6Bottleneck", "VS6 Bottleneck",
                          "The percentage of time in which VS6 pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Vertex Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_VS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl6Bottleneck", "Clipper6 Bottleneck",
                          "The percentage of time in which clipper pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs6Bottleneck", "HS6 Bottleneck",
                          "The percentage of time in which hull shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 3, 9, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds6Bottleneck", "DS6 Bottleneck",
                          "The percentage of time in which domain shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Gs6Bottleneck", "GS6 Bottleneck",
                          "The percentage of time in which geometry shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Geometry Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_GS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf6Bottleneck", "SF6 Bottleneck",
                          "The percentage of time in which strip-fans pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 10, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So6Bottleneck", "SO6 Bottleneck",
                          "The percentage of time in which stream output pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl6Stall", "CL6 Stall",
                          "The percentage of time in which clipper pipeline stage was stalled.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs6Stall", "HS6 Stall",
                          "The percentage of time in which hull stall pipeline stage was stalled.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds6Stall", "DS6 Stall",
                          "The percentage of time in which domain shader pipeline stage was stalled.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf6Stall", "SF6 Stall",
                          "The percentage of time in which strip-fans pipeline stage was stalled.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So6Stall", "SO6 Stall",
                          "The percentage of time in which stream-output pipeline stage was stalled.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hi6DepthBottleneck", "Hi6Depth Bottleneck",
                          "The percentage of time in which early hierarchical depth test pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Hi-Depth Test", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_HZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Bc6Bottleneck", "BC6 Bottleneck",
                          "The percentage of time in which barycentric coordinates calculation pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Barycentric Calc", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_BC * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x168507c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x161b001f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0c1b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x141c0019, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x061c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14090000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a0903c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x160a01f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x160b7c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08850002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x021b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x041b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a1b01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x101b00c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x121b0c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001c0600, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x081c0440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e1c0482, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00062c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020622f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0407000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08070840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e070023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008149c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02081152, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00094003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06090880, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a090001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0c090023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10090003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040a0200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x140a0940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a9654, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a1959, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00195044, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x040b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x080b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x060b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b2200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c00a0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0001aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0201aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032490, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030ca0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e031461, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030a03, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a031401, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012fffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CRenderPipeProfile_Slice7MetricSet::CRenderPipeProfile_Slice7MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CRenderPipeProfile_Slice7MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vf7Bottleneck", "VF7 Bottleneck",
                          "The percentage of time in which vertex fetch pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Input Assembler", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_IA * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Vs7Bottleneck", "VS7 Bottleneck",
                          "The percentage of time in which VS7 pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Vertex Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_VS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl7Bottleneck", "Clipper7 Bottleneck",
                          "The percentage of time in which clipper pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 10, 30, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs7Bottleneck", "HS7 Bottleneck",
                          "The percentage of time in which hull shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 3, 9, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds7Bottleneck", "DS7 Bottleneck",
                          "The percentage of time in which domain shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Gs7Bottleneck", "GS7 Bottleneck",
                          "The percentage of time in which geometry shader pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Geometry Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_GS * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf7Bottleneck", "SF7 Bottleneck",
                          "The percentage of time in which strip-fans pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 10, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So7Bottleneck", "SO7 Bottleneck",
                          "The percentage of time in which stream output pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Cl7Stall", "CL7 Stall",
                          "The percentage of time in which clipper pipeline stage was stalled.",
                          "3D Pipe/Clipper", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_CL * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hs7Stall", "HS7 Stall",
                          "The percentage of time in which hull stall pipeline stage was stalled.",
                          "3D Pipe/Hull Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_HS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Hull|Control,hull|control,HS|TCS", nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Ds7Stall", "DS7 Stall",
                          "The percentage of time in which domain shader pipeline stage was stalled.",
                          "3D Pipe/Domain Shader", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_DS * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, "Domain|Evaluation,domain|evaluation,DS|TES", nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Sf7Stall", "SF7 Stall",
                          "The percentage of time in which strip-fans pipeline stage was stalled.",
                          "3D Pipe/Rasterizer/Strip-Fans", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_SF * 0x100 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "So7Stall", "SO7 Stall",
                          "The percentage of time in which stream-output pipeline stage was stalled.",
                          "3D Pipe/Stream Output", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SO * 0x10000 ), USAGE_FLAG_TIER_4 | USAGE_FLAG_CORRELATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Hi7DepthBottleneck", "Hi7Depth Bottleneck",
                          "The percentage of time in which early hierarchical depth test pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Hi-Depth Test", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_HZ * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "Bc7Bottleneck", "BC7 Bottleneck",
                          "The percentage of time in which barycentric coordinates calculation pipeline stage was slowing down the 3D pipeline.",
                          "3D Pipe/Rasterizer/Barycentric Calc", ( METRIC_GROUP_NAME_ID_3D_PIPE * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_WM * 0x10000 ) | ( METRIC_GROUP_NAME_ID_BC * 0x100 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_INDICATE | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 5, 15, HW_UNIT_GPU, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x178507c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x171b001f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d1b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x151c0019, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x071c0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x25070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15090000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1b0903c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x170a01f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x170b7c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09850002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bfffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085554, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5554, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019fffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x031b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x051b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b1b01c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x111b00c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x131b0c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011c0600, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x091c0440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f1c0482, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01062c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030622f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0507000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09070840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f070023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0108149c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03081152, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01094003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07090880, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b090001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d090023, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11090003, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050a0200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x150a0940, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a9654, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a1959, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01195044, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x050b0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x090b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x070b0000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b2200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0c20, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c0800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c00a0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0001aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0201aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032490, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030ca0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e031461, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030a03, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a031401, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012fffe, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaa8, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CSampler_1MetricSet::CSampler_1MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CSampler_1MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice0";
        metric               = AddMetric( "Sampler00InputAvailable", "Slice0 DualSubslice0 Input Available",
                          "The percentage of time in which slice0 dualsubslice0 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice1";
        metric               = AddMetric( "Sampler01InputAvailable", "Slice0 DualSubslice1 Input Available",
                          "The percentage of time in which slice0 dualsubslice1 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice2";
        metric               = AddMetric( "Sampler02InputAvailable", "Slice0 DualSubslice2 Input Available",
                          "The percentage of time in which slice0 dualsubslice2 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice3";
        metric               = AddMetric( "Sampler03InputAvailable", "Slice0 DualSubslice3 Input Available",
                          "The percentage of time in which slice0 dualsubslice3 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice0";
        metric               = AddMetric( "Sampler10InputAvailable", "Slice1 DualSubslice0 Input Available",
                          "The percentage of time in which slice1 dualsubslice0 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice1";
        metric               = AddMetric( "Sampler11InputAvailable", "Slice1 DualSubslice1 Input Available",
                          "The percentage of time in which slice1 dualsubslice1 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice2";
        metric               = AddMetric( "Sampler12InputAvailable", "Slice1 DualSubslice2 Input Available",
                          "The percentage of time in which slice1 dualsubslice2 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice3";
        metric               = AddMetric( "Sampler13InputAvailable", "Slice1 DualSubslice3 Input Available",
                          "The percentage of time in which slice1 dualsubslice3 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice0";
        metric               = AddMetric( "Sampler20InputAvailable", "Slice2 DualSubslice0 Input Available",
                          "The percentage of time in which slice2 dualsubslice0 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice1";
        metric               = AddMetric( "Sampler21InputAvailable", "Slice2 DualSubslice1 Input Available",
                          "The percentage of time in which slice2 dualsubslice1 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice2";
        metric               = AddMetric( "Sampler22InputAvailable", "Slice2 DualSubslice2 Input Available",
                          "The percentage of time in which slice2 dualsubslice2 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice3";
        metric               = AddMetric( "Sampler23InputAvailable", "Slice2 DualSubslice3 Input Available",
                          "The percentage of time in which slice2 dualsubslice3 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice0";
        metric               = AddMetric( "Sampler30InputAvailable", "Slice3 DualSubslice0 Input Available",
                          "The percentage of time in which slice3 dualsubslice0 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice1";
        metric               = AddMetric( "Sampler31InputAvailable", "Slice3 DualSubslice1 Input Available",
                          "The percentage of time in which slice3 dualsubslice1 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice2";
        metric               = AddMetric( "Sampler32InputAvailable", "Slice3 DualSubslice2 Input Available",
                          "The percentage of time in which slice3 dualsubslice2 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice3";
        metric               = AddMetric( "Sampler33InputAvailable", "Slice3 DualSubslice3 Input Available",
                          "The percentage of time in which slice3 dualsubslice3 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e820160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1ea20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1ec20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1ee20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1f820160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1fa20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1fc20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1fe20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x168205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02844000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02854000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16a20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a31000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14c205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c30400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14e20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e30100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e40100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e50100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x138205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03830040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03840040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03850040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13a20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a30010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11e20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e30001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e40001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e50001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b0f00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02062caa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00071000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0208d655, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00194f00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b10aa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0306002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030800d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000d, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e820160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1ea20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1ec20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1ee20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1f820160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1fa20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1fc20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1fe20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e8205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00844000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00854000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ea20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01231000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0cc205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ce20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e30100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e50100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b8205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01830040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01840040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ba20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a30010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09c205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c30004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09e20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e30001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e40001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e50001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00062caa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00070010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008d655, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019004f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b10aa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0106002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010800d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0002aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030b72, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e0328a2, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40031000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50031028, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x520300b1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a034b49, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ff00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001200ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CSampler_2MetricSet::CSampler_2MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CSampler_2MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice0";
        metric               = AddMetric( "Sampler40InputAvailable", "Slice4 DualSubslice0 Input Available",
                          "The percentage of time in which slice4 dualsubslice0 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice1";
        metric               = AddMetric( "Sampler41InputAvailable", "Slice4 DualSubslice1 Input Available",
                          "The percentage of time in which slice4 dualsubslice1 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice2";
        metric               = AddMetric( "Sampler42InputAvailable", "Slice4 DualSubslice2 Input Available",
                          "The percentage of time in which slice4 dualsubslice2 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice3";
        metric               = AddMetric( "Sampler43InputAvailable", "Slice4 DualSubslice3 Input Available",
                          "The percentage of time in which slice4 dualsubslice3 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice0";
        metric               = AddMetric( "Sampler50InputAvailable", "Slice5 DualSubslice0 Input Available",
                          "The percentage of time in which slice5 dualsubslice0 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice1";
        metric               = AddMetric( "Sampler51InputAvailable", "Slice5 DualSubslice1 Input Available",
                          "The percentage of time in which slice5 dualsubslice1 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice2";
        metric               = AddMetric( "Sampler52InputAvailable", "Slice5 DualSubslice2 Input Available",
                          "The percentage of time in which slice5 dualsubslice2 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice3";
        metric               = AddMetric( "Sampler53InputAvailable", "Slice5 DualSubslice3 Input Available",
                          "The percentage of time in which slice5 dualsubslice3 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice0";
        metric               = AddMetric( "Sampler60InputAvailable", "Slice6 DualSubslice0 Input Available",
                          "The percentage of time in which slice6 dualsubslice0 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice1";
        metric               = AddMetric( "Sampler61InputAvailable", "Slice6 DualSubslice1 Input Available",
                          "The percentage of time in which slice6 dualsubslice1 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice2";
        metric               = AddMetric( "Sampler62InputAvailable", "Slice6 DualSubslice2 Input Available",
                          "The percentage of time in which slice6 dualsubslice2 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice3";
        metric               = AddMetric( "Sampler63InputAvailable", "Slice6 DualSubslice3 Input Available",
                          "The percentage of time in which slice6 dualsubslice3 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice0";
        metric               = AddMetric( "Sampler70InputAvailable", "Slice7 DualSubslice0 Input Available",
                          "The percentage of time in which slice7 dualsubslice0 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice1";
        metric               = AddMetric( "Sampler71InputAvailable", "Slice7 DualSubslice1 Input Available",
                          "The percentage of time in which slice7 dualsubslice1 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice2";
        metric               = AddMetric( "Sampler72InputAvailable", "Slice7 DualSubslice2 Input Available",
                          "The percentage of time in which slice7 dualsubslice2 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice3";
        metric               = AddMetric( "Sampler73InputAvailable", "Slice7 DualSubslice3 Input Available",
                          "The percentage of time in which slice7 dualsubslice3 sampler input is available",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e820160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1ea20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1ec20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1ee20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1f820160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1fa20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1fc20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1fe20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x168205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02844000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02854000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16a20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a31000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14c205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c30400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14e20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e30100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e40100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e50100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x138205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03830040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03840040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03850040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13a20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a30010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11e20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e30001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e40001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e50001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b0f00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02062caa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00071000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0208d655, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00194f00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b10aa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a2000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0306002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030800d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e820160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1ea20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1ec20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1ee20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1f820160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1fa20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1fc20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1fe20160, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e8205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00844000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00854000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ea20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a31000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0cc205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ce20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e30100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e50100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b8205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01830040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01840040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ba20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a30010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09c205c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c30004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09e20017, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e30001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e40001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e50001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00062caa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00070010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008d655, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019004f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b10aa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0106002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010800d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0001aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0004ff00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x480300a0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030d26, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e032cc3, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50031209, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x520300c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a031903, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ff00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001200ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CSampler_3MetricSet::CSampler_3MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CSampler_3MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice0";
        metric               = AddMetric( "Sampler00OutputReady", "Slice0 DualSubslice0 Sampler Output Ready",
                          "The percentage of time in which slice0 dualsubslice0 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice1";
        metric               = AddMetric( "Sampler01OutputReady", "Slice0 DualSubslice1 Sampler Output Ready",
                          "The percentage of time in which slice0 dualsubslice1 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice2";
        metric               = AddMetric( "Sampler02OutputReady", "Slice0 DualSubslice2 Sampler Output Ready",
                          "The percentage of time in which slice0 dualsubslice2 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice3";
        metric               = AddMetric( "Sampler03OutputReady", "Slice0 DualSubslice3 Sampler Output Ready",
                          "The percentage of time in which slice0 dualsubslice3 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice0";
        metric               = AddMetric( "Sampler10OutputReady", "Slice1 DualSubslice0 Sampler Output Ready",
                          "The percentage of time in which slice1 dualsubslice0 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice1";
        metric               = AddMetric( "Sampler11OutputReady", "Slice1 DualSubslice1 Sampler Output Ready",
                          "The percentage of time in which slice1 dualsubslice1 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice2";
        metric               = AddMetric( "Sampler12OutputReady", "Slice1 DualSubslice2 Sampler Output Ready",
                          "The percentage of time in which slice1 dualsubslice2 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice3";
        metric               = AddMetric( "Sampler13OutputReady", "Slice1 DualSubslice3 Sampler Output Ready",
                          "The percentage of time in which slice1 dualsubslice3 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18845200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18a45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18c45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18e45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19845200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19a45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19c45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19e45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0484002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06843c70, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ce403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0584002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f8403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11a403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09a40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13c403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15e403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bff00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000700c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ff0c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0107c000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a3000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c036d08, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e034a52, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50033412, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x520301a0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54031209, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000018, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffc, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000060, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fff3, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000180, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000ffcf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000600, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000ff3f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00001800, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000fcff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00006000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000f3ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00018000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000cfff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00060000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x00003fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CSampler_4MetricSet::CSampler_4MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CSampler_4MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice0";
        metric               = AddMetric( "Sampler20OutputReady", "Slice2 DualSubslice0 Sampler Output Ready",
                          "The percentage of time in which slice2 dualsubslice0 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice1";
        metric               = AddMetric( "Sampler21OutputReady", "Slice2 DualSubslice1 Sampler Output Ready",
                          "The percentage of time in which slice2 dualsubslice1 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice2";
        metric               = AddMetric( "Sampler22OutputReady", "Slice2 DualSubslice2 Sampler Output Ready",
                          "The percentage of time in which slice2 dualsubslice2 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice3";
        metric               = AddMetric( "Sampler23OutputReady", "Slice2 DualSubslice3 Sampler Output Ready",
                          "The percentage of time in which slice2 dualsubslice3 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice0";
        metric               = AddMetric( "Sampler30OutputReady", "Slice3 DualSubslice0 Sampler Output Ready",
                          "The percentage of time in which slice3 dualsubslice0 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice1";
        metric               = AddMetric( "Sampler31OutputReady", "Slice3 DualSubslice1 Sampler Output Ready",
                          "The percentage of time in which slice3 dualsubslice1 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice2";
        metric               = AddMetric( "Sampler32OutputReady", "Slice3 DualSubslice2 Sampler Output Ready",
                          "The percentage of time in which slice3 dualsubslice2 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice3";
        metric               = AddMetric( "Sampler33OutputReady", "Slice3 DualSubslice3 Sampler Output Ready",
                          "The percentage of time in which slice3 dualsubslice3 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000d, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18845200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18a45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18c45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18e45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19845200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19a45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19c45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19e45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0484002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06843c70, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ce403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0584002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f8403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11a403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09a40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13c403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15e403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bff00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000700c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ff0c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0107c000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a3000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0002aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0202aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c032442, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e0318c6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50031006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030603, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000018, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffc, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000060, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fff3, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000180, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000ffcf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000600, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000ff3f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00001800, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000fcff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00006000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000f3ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00018000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000cfff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00060000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x00003fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CSampler_5MetricSet::CSampler_5MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CSampler_5MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice0";
        metric               = AddMetric( "Sampler40OutputReady", "Slice4 DualSubslice0 Sampler Output Ready",
                          "The percentage of time in which slice4 dualsubslice0 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice1";
        metric               = AddMetric( "Sampler41OutputReady", "Slice4 DualSubslice1 Sampler Output Ready",
                          "The percentage of time in which slice4 dualsubslice1 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice2";
        metric               = AddMetric( "Sampler42OutputReady", "Slice4 DualSubslice2 Sampler Output Ready",
                          "The percentage of time in which slice4 dualsubslice2 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice3";
        metric               = AddMetric( "Sampler43OutputReady", "Slice4 DualSubslice3 Sampler Output Ready",
                          "The percentage of time in which slice4 dualsubslice3 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice0";
        metric               = AddMetric( "Sampler50OutputReady", "Slice5 DualSubslice0 Sampler Output Ready",
                          "The percentage of time in which slice5 dualsubslice0 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice1";
        metric               = AddMetric( "Sampler51OutputReady", "Slice5 DualSubslice1 Sampler Output Ready",
                          "The percentage of time in which slice5 dualsubslice1 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice2";
        metric               = AddMetric( "Sampler52OutputReady", "Slice5 DualSubslice2 Sampler Output Ready",
                          "The percentage of time in which slice5 dualsubslice2 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice3";
        metric               = AddMetric( "Sampler53OutputReady", "Slice5 DualSubslice3 Sampler Output Ready",
                          "The percentage of time in which slice5 dualsubslice3 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18845200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18a45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18c45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18e45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19845200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19a45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19c45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19e45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0484002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06843c70, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ce403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0584002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f8403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11a403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09a40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13c403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15e403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bff00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000700c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ff0c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0107c000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a3000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0004ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c032442, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e0318c6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50031006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030603, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000018, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffc, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000060, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fff3, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000180, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000ffcf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000600, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000ff3f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00001800, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000fcff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00006000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000f3ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00018000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000cfff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00060000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x00003fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CSampler_6MetricSet::CSampler_6MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CSampler_6MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice0";
        metric               = AddMetric( "Sampler60OutputReady", "Slice6 DualSubslice0 Sampler Output Ready",
                          "The percentage of time in which slice6 dualsubslice0 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice1";
        metric               = AddMetric( "Sampler61OutputReady", "Slice6 DualSubslice1 Sampler Output Ready",
                          "The percentage of time in which slice6 dualsubslice1 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice2";
        metric               = AddMetric( "Sampler62OutputReady", "Slice6 DualSubslice2 Sampler Output Ready",
                          "The percentage of time in which slice6 dualsubslice2 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice3";
        metric               = AddMetric( "Sampler63OutputReady", "Slice6 DualSubslice3 Sampler Output Ready",
                          "The percentage of time in which slice6 dualsubslice3 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice0";
        metric               = AddMetric( "Sampler70OutputReady", "Slice7 DualSubslice0 Sampler Output Ready",
                          "The percentage of time in which slice7 dualsubslice0 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice1";
        metric               = AddMetric( "Sampler71OutputReady", "Slice7 DualSubslice1 Sampler Output Ready",
                          "The percentage of time in which slice7 dualsubslice1 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice2";
        metric               = AddMetric( "Sampler72OutputReady", "Slice7 DualSubslice2 Sampler Output Ready",
                          "The percentage of time in which slice7 dualsubslice2 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice3";
        metric               = AddMetric( "Sampler73OutputReady", "Slice7 DualSubslice3 Sampler Output Ready",
                          "The percentage of time in which slice7 dualsubslice3 sampler output is ready",
                          "GPU/Sampler", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_SAMPLER * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_SUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18845200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18a45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18c45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18e45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19845200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19a45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19c45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x19e45200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0484002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06843c70, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ce403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0584002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f8403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03840000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11a403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09a40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13c403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e4002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15e403c7, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e40000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bff00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000700c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ff0c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0107c000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a3000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0001aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0201aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c032442, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e0318c6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50031006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030603, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000018, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffc, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000060, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fff3, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000180, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000ffcf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000600, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000ff3f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00001800, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000fcff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00006000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000f3ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00018000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000cfff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00060000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x00003fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_1MetricSet::CTDL_1MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_1MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice0";
        metric               = AddMetric( "ThreadHeader00Ready", "Thread Header Ready on Slice0 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice1";
        metric               = AddMetric( "ThreadHeader01Ready", "Thread Header Ready on Slice0 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice2";
        metric               = AddMetric( "ThreadHeader02Ready", "Thread Header Ready on Slice0 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice3";
        metric               = AddMetric( "ThreadHeader03Ready", "Thread Header Ready on Slice0 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice0";
        metric               = AddMetric( "ThreadHeader00ReadyPort0", "Thread Header Ready on Slice0 DualSubslice0 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice0 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice1";
        metric               = AddMetric( "ThreadHeader01ReadyPort0", "Thread Header Ready on Slice0 DualSubslice1 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice1 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice2";
        metric               = AddMetric( "ThreadHeader02ReadyPort0", "Thread Header Ready on Slice0 DualSubslice2 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice2 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice3";
        metric               = AddMetric( "ThreadHeader03ReadyPort0", "Thread Header Ready on Slice0 DualSubslice3 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice3 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice0";
        metric               = AddMetric( "ThreadHeader00ReadyPort1", "Thread Header Ready on Slice0 DualSubslice0 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice0 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice1";
        metric               = AddMetric( "ThreadHeader01ReadyPort1", "Thread Header Ready on Slice0 DualSubslice1 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice1 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice2";
        metric               = AddMetric( "ThreadHeader02ReadyPort1", "Thread Header Ready on Slice0 DualSubslice2 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice2 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice3";
        metric               = AddMetric( "ThreadHeader03ReadyPort1", "Thread Header Ready on Slice0 DualSubslice3 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice3 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice0";
        metric               = AddMetric( "ThreadHeader00ReadyPort2", "Thread Header Ready on Slice0 DualSubslice0 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice0 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice1";
        metric               = AddMetric( "ThreadHeader01ReadyPort2", "Thread Header Ready on Slice0 DualSubslice1 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice1 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice2";
        metric               = AddMetric( "ThreadHeader02ReadyPort2", "Thread Header Ready on Slice0 DualSubslice2 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice2 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice3";
        metric               = AddMetric( "ThreadHeader03ReadyPort2", "Thread Header Ready on Slice0 DualSubslice3 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice3 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28826f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28a26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28c26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28e26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e820c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12820fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16820f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00834001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02834040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00844001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02844040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00854001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02854040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ea20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12a2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16a2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a31004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a31010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a41004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a41010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a51004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a51010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac20031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0cc20c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10c20fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14c20f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c30404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c40404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c50404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ae20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ce20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10e2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14e2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e30140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e30101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e40101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e50140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e50101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00062c38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02062c2c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00071118, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008d697, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0208d6d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00194442, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b1004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b1010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a2224, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e032100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030090, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030109, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00044408, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000777e, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00022210, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000bbbd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00011120, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000dddb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x000088c0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000eee7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_2MetricSet::CTDL_2MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_2MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice0";
        metric               = AddMetric( "ThreadHeader10Ready", "Thread Header Ready on Slice1 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice1";
        metric               = AddMetric( "ThreadHeader11Ready", "Thread Header Ready on Slice1 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice2";
        metric               = AddMetric( "ThreadHeader12Ready", "Thread Header Ready on Slice1 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice3";
        metric               = AddMetric( "ThreadHeader13Ready", "Thread Header Ready on Slice1 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice0";
        metric               = AddMetric( "ThreadHeader10ReadyPort0", "Thread Header Ready on Slice1 DualSubslice0 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice0 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice1";
        metric               = AddMetric( "ThreadHeader11ReadyPort0", "Thread Header Ready on Slice1 DualSubslice1 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice1 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice2";
        metric               = AddMetric( "ThreadHeader12ReadyPort0", "Thread Header Ready on Slice1 DualSubslice2 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice2 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice3";
        metric               = AddMetric( "ThreadHeader13ReadyPort0", "Thread Header Ready on Slice1 DualSubslice3 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice3 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice0";
        metric               = AddMetric( "ThreadHeader10ReadyPort1", "Thread Header Ready on Slice1 DualSubslice0 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice0 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice1";
        metric               = AddMetric( "ThreadHeader11ReadyPort1", "Thread Header Ready on Slice1 DualSubslice1 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice1 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice2";
        metric               = AddMetric( "ThreadHeader12ReadyPort1", "Thread Header Ready on Slice1 DualSubslice2 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice2 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice3";
        metric               = AddMetric( "ThreadHeader13ReadyPort1", "Thread Header Ready on Slice1 DualSubslice3 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice3 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice0";
        metric               = AddMetric( "ThreadHeader10ReadyPort2", "Thread Header Ready on Slice1 DualSubslice0 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice0 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice1";
        metric               = AddMetric( "ThreadHeader11ReadyPort2", "Thread Header Ready on Slice1 DualSubslice1 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice1 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice2";
        metric               = AddMetric( "ThreadHeader12ReadyPort2", "Thread Header Ready on Slice1 DualSubslice2 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice2 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice3";
        metric               = AddMetric( "ThreadHeader13ReadyPort2", "Thread Header Ready on Slice1 DualSubslice3 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice3 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29826f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29a26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29c26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29e26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09820031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f820c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13820fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17820f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01834001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03834040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01844001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03844040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01854001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03854040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09a20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fa20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13a2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17a2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a31004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a31010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a41004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a41010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a51004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a51010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0bc20031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0dc20c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c20fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15c20f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c30410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c40410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c50410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0be20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0de20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11e2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15e2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e30140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e30101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e40140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e40101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e50140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e50101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01062c38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03062c2c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01071118, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0108d697, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308d6d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01194442, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b1004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b1010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a2224, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c0410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e032100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030090, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030109, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00044408, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000777e, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00022210, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000bbbd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00011120, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000dddb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x000088c0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000eee7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_3MetricSet::CTDL_3MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_3MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice0";
        metric               = AddMetric( "ThreadHeader20Ready", "Thread Header Ready on Slice2 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice1";
        metric               = AddMetric( "ThreadHeader21Ready", "Thread Header Ready on Slice2 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice2";
        metric               = AddMetric( "ThreadHeader22Ready", "Thread Header Ready on Slice2 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice3";
        metric               = AddMetric( "ThreadHeader23Ready", "Thread Header Ready on Slice2 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice0";
        metric               = AddMetric( "ThreadHeader20ReadyPort0", "Thread Header Ready on Slice2 DualSubslice0 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice0 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice1";
        metric               = AddMetric( "ThreadHeader21ReadyPort0", "Thread Header Ready on Slice2 DualSubslice1 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice1 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice2";
        metric               = AddMetric( "ThreadHeader22ReadyPort0", "Thread Header Ready on Slice2 DualSubslice2 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice2 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice3";
        metric               = AddMetric( "ThreadHeader23ReadyPort0", "Thread Header Ready on Slice2 DualSubslice3 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice3 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice0";
        metric               = AddMetric( "ThreadHeader20ReadyPort1", "Thread Header Ready on Slice2 DualSubslice0 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice0 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice1";
        metric               = AddMetric( "ThreadHeader21ReadyPort1", "Thread Header Ready on Slice2 DualSubslice1 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice1 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice2";
        metric               = AddMetric( "ThreadHeader22ReadyPort1", "Thread Header Ready on Slice2 DualSubslice2 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice2 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice3";
        metric               = AddMetric( "ThreadHeader23ReadyPort1", "Thread Header Ready on Slice2 DualSubslice3 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice3 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice0";
        metric               = AddMetric( "ThreadHeader20ReadyPort2", "Thread Header Ready on Slice2 DualSubslice0 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice0 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice1";
        metric               = AddMetric( "ThreadHeader21ReadyPort2", "Thread Header Ready on Slice2 DualSubslice1 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice1 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice2";
        metric               = AddMetric( "ThreadHeader22ReadyPort2", "Thread Header Ready on Slice2 DualSubslice2 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice2 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice3";
        metric               = AddMetric( "ThreadHeader23ReadyPort2", "Thread Header Ready on Slice2 DualSubslice3 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice3 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000d, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28826f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28a26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28c26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28e26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e820c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12820fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16820f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00834001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02834040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00844001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02844040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00854001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02854040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ea20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12a2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16a2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01231004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03231010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a41004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a41010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a51004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a51010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac20031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0cc20c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10c20fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14c20f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c30404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c40404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c50404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ae20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ce20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10e2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14e2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e30140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e30101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e40101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e50140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e50101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00062c38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02062c2c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00071118, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008d697, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0208d6d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00194442, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b1004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b1010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a2224, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0002aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0202aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030043, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00044408, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000777e, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00022210, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000bbbd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00011120, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000dddb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x000088c0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000eee7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_4MetricSet::CTDL_4MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_4MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice0";
        metric               = AddMetric( "ThreadHeader30Ready", "Thread Header Ready on Slice3 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice1";
        metric               = AddMetric( "ThreadHeader31Ready", "Thread Header Ready on Slice3 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice2";
        metric               = AddMetric( "ThreadHeader32Ready", "Thread Header Ready on Slice3 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice3";
        metric               = AddMetric( "ThreadHeader33Ready", "Thread Header Ready on Slice3 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice0";
        metric               = AddMetric( "ThreadHeader30ReadyPort0", "Thread Header Ready on Slice3 DualSubslice0 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice0 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice1";
        metric               = AddMetric( "ThreadHeader31ReadyPort0", "Thread Header Ready on Slice3 DualSubslice1 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice1 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice2";
        metric               = AddMetric( "ThreadHeader32ReadyPort0", "Thread Header Ready on Slice3 DualSubslice2 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice2 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice3";
        metric               = AddMetric( "ThreadHeader33ReadyPort0", "Thread Header Ready on Slice3 DualSubslice3 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice3 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice0";
        metric               = AddMetric( "ThreadHeader30ReadyPort1", "Thread Header Ready on Slice3 DualSubslice0 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice0 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice1";
        metric               = AddMetric( "ThreadHeader31ReadyPort1", "Thread Header Ready on Slice3 DualSubslice1 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice1 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice2";
        metric               = AddMetric( "ThreadHeader32ReadyPort1", "Thread Header Ready on Slice3 DualSubslice2 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice2 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice3";
        metric               = AddMetric( "ThreadHeader33ReadyPort1", "Thread Header Ready on Slice3 DualSubslice3 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice3 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice0";
        metric               = AddMetric( "ThreadHeader30ReadyPort2", "Thread Header Ready on Slice3 DualSubslice0 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice0 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice1";
        metric               = AddMetric( "ThreadHeader31ReadyPort2", "Thread Header Ready on Slice3 DualSubslice1 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice1 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice2";
        metric               = AddMetric( "ThreadHeader32ReadyPort2", "Thread Header Ready on Slice3 DualSubslice2 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice2 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice3";
        metric               = AddMetric( "ThreadHeader33ReadyPort2", "Thread Header Ready on Slice3 DualSubslice3 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice3 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000d, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29826f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29a26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29c26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29e26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09820031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f820c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13820fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17820f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01834001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03834040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01844001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03844040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01854001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03854040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09a20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fa20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13a2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17a2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a31004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a31010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a41004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a41010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a51004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a51010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0bc20031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0dc20c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c20fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15c20f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c30410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c40410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c50410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0be20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0de20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11e2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15e2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e30140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e30101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e40140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e40101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e50140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e50101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01062c38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03062c2c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01071118, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0108d697, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308d6d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01194442, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b1004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b1010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a2224, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c0410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0002aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0202aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030043, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00044408, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000777e, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00022210, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000bbbd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00011120, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000dddb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x000088c0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000eee7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_5MetricSet::CTDL_5MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_5MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice0";
        metric               = AddMetric( "ThreadHeader40Ready", "Thread Header Ready on Slice4 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice1";
        metric               = AddMetric( "ThreadHeader41Ready", "Thread Header Ready on Slice4 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice2";
        metric               = AddMetric( "ThreadHeader42Ready", "Thread Header Ready on Slice4 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice3";
        metric               = AddMetric( "ThreadHeader43Ready", "Thread Header Ready on Slice4 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice0";
        metric               = AddMetric( "ThreadHeader40ReadyPort0", "Thread Header Ready on Slice4 DualSubslice0 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice0 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice1";
        metric               = AddMetric( "ThreadHeader41ReadyPort0", "Thread Header Ready on Slice4 DualSubslice1 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice1 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice2";
        metric               = AddMetric( "ThreadHeader42ReadyPort0", "Thread Header Ready on Slice4 DualSubslice2 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice2 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice3";
        metric               = AddMetric( "ThreadHeader43ReadyPort0", "Thread Header Ready on Slice4 DualSubslice3 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice3 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice0";
        metric               = AddMetric( "ThreadHeader40ReadyPort1", "Thread Header Ready on Slice4 DualSubslice0 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice0 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice1";
        metric               = AddMetric( "ThreadHeader41ReadyPort1", "Thread Header Ready on Slice4 DualSubslice1 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice1 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice2";
        metric               = AddMetric( "ThreadHeader42ReadyPort1", "Thread Header Ready on Slice4 DualSubslice2 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice2 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice3";
        metric               = AddMetric( "ThreadHeader43ReadyPort1", "Thread Header Ready on Slice4 DualSubslice3 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice3 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice0";
        metric               = AddMetric( "ThreadHeader40ReadyPort2", "Thread Header Ready on Slice4 DualSubslice0 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice0 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice1";
        metric               = AddMetric( "ThreadHeader41ReadyPort2", "Thread Header Ready on Slice4 DualSubslice1 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice1 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice2";
        metric               = AddMetric( "ThreadHeader42ReadyPort2", "Thread Header Ready on Slice4 DualSubslice2 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice2 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice3";
        metric               = AddMetric( "ThreadHeader43ReadyPort2", "Thread Header Ready on Slice4 DualSubslice3 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice3 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28826f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28a26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28c26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28e26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e820c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12820fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16820f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00834001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02834040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00844001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02844040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00854001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02854040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ea20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12a2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16a2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a31004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a31010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a41004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a41010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a51004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a51010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac20031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0cc20c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10c20fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14c20f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c30404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c40404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c50404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ae20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ce20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10e2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14e2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e30140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e30101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e40101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e50140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e50101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00062c38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02062c2c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00071118, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008d697, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0208d6d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00194442, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b1004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b1010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a2224, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0004ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030043, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00044408, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000777e, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00022210, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000bbbd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00011120, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000dddb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x000088c0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000eee7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_6MetricSet::CTDL_6MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_6MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice0";
        metric               = AddMetric( "ThreadHeader50Ready", "Thread Header Ready on Slice5 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice1";
        metric               = AddMetric( "ThreadHeader51Ready", "Thread Header Ready on Slice5 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice2";
        metric               = AddMetric( "ThreadHeader52Ready", "Thread Header Ready on Slice5 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice3";
        metric               = AddMetric( "ThreadHeader53Ready", "Thread Header Ready on Slice5 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice0";
        metric               = AddMetric( "ThreadHeader50ReadyPort0", "Thread Header Ready on Slice5 DualSubslice0 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice0 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice1";
        metric               = AddMetric( "ThreadHeader51ReadyPort0", "Thread Header Ready on Slice5 DualSubslice1 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice1 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice2";
        metric               = AddMetric( "ThreadHeader52ReadyPort0", "Thread Header Ready on Slice5 DualSubslice2 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice2 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice3";
        metric               = AddMetric( "ThreadHeader53ReadyPort0", "Thread Header Ready on Slice5 DualSubslice3 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice3 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice0";
        metric               = AddMetric( "ThreadHeader50ReadyPort1", "Thread Header Ready on Slice5 DualSubslice0 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice0 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice1";
        metric               = AddMetric( "ThreadHeader51ReadyPort1", "Thread Header Ready on Slice5 DualSubslice1 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice1 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice2";
        metric               = AddMetric( "ThreadHeader52ReadyPort1", "Thread Header Ready on Slice5 DualSubslice2 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice2 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice3";
        metric               = AddMetric( "ThreadHeader53ReadyPort1", "Thread Header Ready on Slice5 DualSubslice3 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice3 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice0";
        metric               = AddMetric( "ThreadHeader50ReadyPort2", "Thread Header Ready on Slice5 DualSubslice0 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice0 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice1";
        metric               = AddMetric( "ThreadHeader51ReadyPort2", "Thread Header Ready on Slice5 DualSubslice1 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice1 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice2";
        metric               = AddMetric( "ThreadHeader52ReadyPort2", "Thread Header Ready on Slice5 DualSubslice2 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice2 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice3";
        metric               = AddMetric( "ThreadHeader53ReadyPort2", "Thread Header Ready on Slice5 DualSubslice3 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice3 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29826f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29a26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29c26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29e26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09820031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f820c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13820fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17820f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01834001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03834040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01844001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03844040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01854001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03854040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09a20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fa20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13a2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17a2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a31004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a31010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a41004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a41010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a51004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a51010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0bc20031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0dc20c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c20fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15c20f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c30410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c40410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c50410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0be20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0de20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11e2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15e2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e30140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e30101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e40140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e40101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e50140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e50101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01062c38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03062c2c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01071118, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0108d697, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308d6d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01194442, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b1004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b1010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a2224, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c0410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0004ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030043, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00044408, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000777e, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00022210, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000bbbd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00011120, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000dddb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x000088c0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000eee7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_7MetricSet::CTDL_7MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_7MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice0";
        metric               = AddMetric( "ThreadHeader60Ready", "Thread Header Ready on Slice6 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice1";
        metric               = AddMetric( "ThreadHeader61Ready", "Thread Header Ready on Slice6 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice2";
        metric               = AddMetric( "ThreadHeader62Ready", "Thread Header Ready on Slice6 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice3";
        metric               = AddMetric( "ThreadHeader63Ready", "Thread Header Ready on Slice6 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice0";
        metric               = AddMetric( "ThreadHeader60ReadyPort0", "Thread Header Ready on Slice6 DualSubslice0 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice0 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice1";
        metric               = AddMetric( "ThreadHeader61ReadyPort0", "Thread Header Ready on Slice6 DualSubslice1 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice1 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice2";
        metric               = AddMetric( "ThreadHeader62ReadyPort0", "Thread Header Ready on Slice6 DualSubslice2 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice2 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice3";
        metric               = AddMetric( "ThreadHeader63ReadyPort0", "Thread Header Ready on Slice6 DualSubslice3 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice3 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice0";
        metric               = AddMetric( "ThreadHeader60ReadyPort1", "Thread Header Ready on Slice6 DualSubslice0 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice0 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice1";
        metric               = AddMetric( "ThreadHeader61ReadyPort1", "Thread Header Ready on Slice6 DualSubslice1 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice1 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice2";
        metric               = AddMetric( "ThreadHeader62ReadyPort1", "Thread Header Ready on Slice6 DualSubslice2 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice2 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice3";
        metric               = AddMetric( "ThreadHeader63ReadyPort1", "Thread Header Ready on Slice6 DualSubslice3 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice3 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice0";
        metric               = AddMetric( "ThreadHeader60ReadyPort2", "Thread Header Ready on Slice6 DualSubslice0 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice0 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice1";
        metric               = AddMetric( "ThreadHeader61ReadyPort2", "Thread Header Ready on Slice6 DualSubslice1 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice1 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice2";
        metric               = AddMetric( "ThreadHeader62ReadyPort2", "Thread Header Ready on Slice6 DualSubslice2 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice2 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice3";
        metric               = AddMetric( "ThreadHeader63ReadyPort2", "Thread Header Ready on Slice6 DualSubslice3 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice3 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28826f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28a26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28c26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28e26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0e820c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12820fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16820f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00834001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02834040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00844001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02844040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00854001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02854040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ea20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12a2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16a2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a31004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a31010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a41004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a41010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a51004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a51010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac20031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0cc20c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10c20fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14c20f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c30404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c40404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c50404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ae20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ce20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10e2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14e2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e30140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e30101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e40101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e50140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e50101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00062c38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02062c2c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00071118, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008d697, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0208d6d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00194442, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b1004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b1010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a2224, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0001aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0201aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030043, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00044408, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000777e, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00022210, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000bbbd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00011120, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000dddb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x000088c0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000eee7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_8MetricSet::CTDL_8MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_8MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice0";
        metric               = AddMetric( "ThreadHeader70Ready", "Thread Header Ready on Slice7 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice1";
        metric               = AddMetric( "ThreadHeader71Ready", "Thread Header Ready on Slice7 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice2";
        metric               = AddMetric( "ThreadHeader72Ready", "Thread Header Ready on Slice7 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice3";
        metric               = AddMetric( "ThreadHeader73Ready", "Thread Header Ready on Slice7 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice0";
        metric               = AddMetric( "ThreadHeader70ReadyPort0", "Thread Header Ready on Slice7 DualSubslice0 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice0 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice1";
        metric               = AddMetric( "ThreadHeader71ReadyPort0", "Thread Header Ready on Slice7 DualSubslice1 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice1 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice2";
        metric               = AddMetric( "ThreadHeader72ReadyPort0", "Thread Header Ready on Slice7 DualSubslice2 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice2 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice3";
        metric               = AddMetric( "ThreadHeader73ReadyPort0", "Thread Header Ready on Slice7 DualSubslice3 Thread Dispatcher Port 0",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice3 thread dispatcher port 0",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice0";
        metric               = AddMetric( "ThreadHeader70ReadyPort1", "Thread Header Ready on Slice7 DualSubslice0 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice0 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice1";
        metric               = AddMetric( "ThreadHeader71ReadyPort1", "Thread Header Ready on Slice7 DualSubslice1 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice1 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice2";
        metric               = AddMetric( "ThreadHeader72ReadyPort1", "Thread Header Ready on Slice7 DualSubslice2 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice2 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice3";
        metric               = AddMetric( "ThreadHeader73ReadyPort1", "Thread Header Ready on Slice7 DualSubslice3 Thread Dispatcher Port 1",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice3 thread dispatcher port 1",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice0";
        metric               = AddMetric( "ThreadHeader70ReadyPort2", "Thread Header Ready on Slice7 DualSubslice0 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice0 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice1";
        metric               = AddMetric( "ThreadHeader71ReadyPort2", "Thread Header Ready on Slice7 DualSubslice1 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice1 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice2";
        metric               = AddMetric( "ThreadHeader72ReadyPort2", "Thread Header Ready on Slice7 DualSubslice2 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice2 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice3";
        metric               = AddMetric( "ThreadHeader73ReadyPort2", "Thread Header Ready on Slice7 DualSubslice3 Thread Dispatcher Port 2",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice3 thread dispatcher port 2",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29826f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29a26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29c26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29e26f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09820031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0f820c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13820fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17820f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01834001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03834040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01844001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03844040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01854001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03854040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09a20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fa20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13a2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17a2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a31004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a31010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a41004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a41010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a51004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a51010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0bc20031, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0dc20c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c20fc0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15c20f80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c30410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c40410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c50410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0be20c40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0de20030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11e2003f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15e2003e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e30140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e30101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e40140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e40101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e50140, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e50101, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01062c38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03062c2c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01071118, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0108d697, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308d6d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01194442, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b1004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b1010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a2224, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c0410, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0404, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0001aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0201aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030043, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00044408, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000777e, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00022210, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000bbbd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00011120, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000dddb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x000088c0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000eee7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_9MetricSet::CTDL_9MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_9MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice0";
        metric               = AddMetric( "NonPSThread00ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice0 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice0 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice1";
        metric               = AddMetric( "NonPSThread01ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice0 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice0 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice2";
        metric               = AddMetric( "NonPSThread02ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice0 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice0 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice3";
        metric               = AddMetric( "NonPSThread03ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice0 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice0 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice0";
        metric               = AddMetric( "NonPSThread10ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice1 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice1 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice1";
        metric               = AddMetric( "NonPSThread11ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice1 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice1 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice2";
        metric               = AddMetric( "NonPSThread12ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice1 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice1 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice3";
        metric               = AddMetric( "NonPSThread13ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice1 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice1 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice0";
        metric               = AddMetric( "ThreadHeader00ReadyPort3", "Thread Header Ready on Slice0 DualSubslice0 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice0 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice1";
        metric               = AddMetric( "ThreadHeader01ReadyPort3", "Thread Header Ready on Slice0 DualSubslice1 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice1 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice2";
        metric               = AddMetric( "ThreadHeader02ReadyPort3", "Thread Header Ready on Slice0 DualSubslice2 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice2 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice3";
        metric               = AddMetric( "ThreadHeader03ReadyPort3", "Thread Header Ready on Slice0 DualSubslice3 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice0 dualsubslice3 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice0";
        metric               = AddMetric( "ThreadHeader10ReadyPort3", "Thread Header Ready on Slice1 DualSubslice0 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice0 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice1";
        metric               = AddMetric( "ThreadHeader11ReadyPort3", "Thread Header Ready on Slice1 DualSubslice1 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice1 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice2";
        metric               = AddMetric( "ThreadHeader12ReadyPort3", "Thread Header Ready on Slice1 DualSubslice2 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice2 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice3";
        metric               = AddMetric( "ThreadHeader13ReadyPort3", "Thread Header Ready on Slice1 DualSubslice3 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice1 dualsubslice3 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28827360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28a27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28c27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28e27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29827360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29a27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29c27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29e27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16820e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02844000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02854000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16a20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a30004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a31000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac20035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14c20e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c30400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ae20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14e20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e30040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e30100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e40100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e50040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e50100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d820035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13820e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01830100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03830040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01840100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03840040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03850040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0da20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13a20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a30400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a30010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fc20035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c20e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c31000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fe20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11e20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e30001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e44000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e40001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e54000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e50001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b0ff0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aa38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02062caa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00071008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085597, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0208d655, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00194ff2, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baa04, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b10aa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a2004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01063800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0306002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01089700, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030800d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190420, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0240, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c1000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c034b72, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e032752, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a034b49, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffe, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fffd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000fffb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000fff7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000ffef, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000ffdf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000ffbf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x0000ff7f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_10MetricSet::CTDL_10MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_10MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice0";
        metric               = AddMetric( "NonPSThread20ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice2 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice2 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice1";
        metric               = AddMetric( "NonPSThread21ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice2 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice2 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice2";
        metric               = AddMetric( "NonPSThread22ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice2 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice2 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice3";
        metric               = AddMetric( "NonPSThread23ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice2 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice2 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice0";
        metric               = AddMetric( "NonPSThread30ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice3 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice3 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice1";
        metric               = AddMetric( "NonPSThread31ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice3 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice3 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice2";
        metric               = AddMetric( "NonPSThread32ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice3 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice3 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice3";
        metric               = AddMetric( "NonPSThread33ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice3 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice3 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice0";
        metric               = AddMetric( "ThreadHeader20ReadyPort3", "Thread Header Ready on Slice2 DualSubslice0 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice0 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice1";
        metric               = AddMetric( "ThreadHeader21ReadyPort3", "Thread Header Ready on Slice2 DualSubslice1 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice1 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice2";
        metric               = AddMetric( "ThreadHeader22ReadyPort3", "Thread Header Ready on Slice2 DualSubslice2 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice2 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice3";
        metric               = AddMetric( "ThreadHeader23ReadyPort3", "Thread Header Ready on Slice2 DualSubslice3 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice2 dualsubslice3 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice0";
        metric               = AddMetric( "ThreadHeader30ReadyPort3", "Thread Header Ready on Slice3 DualSubslice0 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice0 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice1";
        metric               = AddMetric( "ThreadHeader31ReadyPort3", "Thread Header Ready on Slice3 DualSubslice1 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice1 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice2";
        metric               = AddMetric( "ThreadHeader32ReadyPort3", "Thread Header Ready on Slice3 DualSubslice2 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice2 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice3";
        metric               = AddMetric( "ThreadHeader33ReadyPort3", "Thread Header Ready on Slice3 DualSubslice3 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice3 dualsubslice3 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000d, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28827360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28a27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28c27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28e27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29827360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29a27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29c27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29e27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16820e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02844000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02854000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16a20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01230004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03231000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac20035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14c20e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c30400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ae20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14e20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e30040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e30100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e40100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e50040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e50100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d820035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13820e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01830100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03830040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01840100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03840040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03850040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0da20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13a20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a30400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a30010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fc20035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c20e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c31000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fe20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11e20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e30001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e44000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e40001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e54000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e50001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b0ff0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aa38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02062caa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00071008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085597, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0208d655, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00194ff2, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baa04, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b10aa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a2004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01063800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0306002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01089700, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030800d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190420, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0240, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c1000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0002aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0202aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c031926, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030d06, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a031903, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffe, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fffd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000fffb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000fff7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000ffef, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000ffdf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000ffbf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x0000ff7f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_11MetricSet::CTDL_11MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_11MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice0";
        metric               = AddMetric( "NonPSThread40ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice4 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice4 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice1";
        metric               = AddMetric( "NonPSThread41ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice4 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice4 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice2";
        metric               = AddMetric( "NonPSThread42ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice4 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice4 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice3";
        metric               = AddMetric( "NonPSThread43ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice4 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice4 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice0";
        metric               = AddMetric( "NonPSThread50ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice5 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice5 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice1";
        metric               = AddMetric( "NonPSThread51ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice5 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice5 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice2";
        metric               = AddMetric( "NonPSThread52ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice5 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice5 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice3";
        metric               = AddMetric( "NonPSThread53ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice5 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice5 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice0";
        metric               = AddMetric( "ThreadHeader40ReadyPort3", "Thread Header Ready on Slice4 DualSubslice0 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice0 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice1";
        metric               = AddMetric( "ThreadHeader41ReadyPort3", "Thread Header Ready on Slice4 DualSubslice1 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice1 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice2";
        metric               = AddMetric( "ThreadHeader42ReadyPort3", "Thread Header Ready on Slice4 DualSubslice2 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice2 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice3";
        metric               = AddMetric( "ThreadHeader43ReadyPort3", "Thread Header Ready on Slice4 DualSubslice3 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice4 dualsubslice3 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice0";
        metric               = AddMetric( "ThreadHeader50ReadyPort3", "Thread Header Ready on Slice5 DualSubslice0 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice0 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice1";
        metric               = AddMetric( "ThreadHeader51ReadyPort3", "Thread Header Ready on Slice5 DualSubslice1 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice1 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice2";
        metric               = AddMetric( "ThreadHeader52ReadyPort3", "Thread Header Ready on Slice5 DualSubslice2 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice2 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice3";
        metric               = AddMetric( "ThreadHeader53ReadyPort3", "Thread Header Ready on Slice5 DualSubslice3 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice5 dualsubslice3 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28827360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28a27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28c27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28e27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29827360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29a27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29c27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29e27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16820e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02844000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02854000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16a20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a30004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a31000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac20035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14c20e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c30400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ae20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14e20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e30040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e30100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e40100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e50040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e50100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d820035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13820e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01830100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03830040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01840100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03840040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03850040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0da20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13a20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a30400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a30010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fc20035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c20e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c31000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fe20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11e20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e30001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e44000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e40001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e54000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e50001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b0ff0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aa38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02062caa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00071008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085597, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0208d655, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00194ff2, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baa04, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b10aa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a2004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01063800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0306002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01089700, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030800d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190420, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0240, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c1000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0004ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c031926, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030d06, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a031903, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffe, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fffd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000fffb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000fff7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000ffef, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000ffdf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000ffbf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x0000ff7f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_12MetricSet::CTDL_12MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_12MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice0";
        metric               = AddMetric( "NonPSThread60ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice6 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice6 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice1";
        metric               = AddMetric( "NonPSThread61ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice6 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice6 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice2";
        metric               = AddMetric( "NonPSThread62ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice6 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice6 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice3";
        metric               = AddMetric( "NonPSThread63ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice6 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice6 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice0";
        metric               = AddMetric( "NonPSThread70ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice7 DualSubslice0 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice7 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice1";
        metric               = AddMetric( "NonPSThread71ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice7 DualSubslice1 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice7 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice2";
        metric               = AddMetric( "NonPSThread72ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice7 DualSubslice2 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice7 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice3";
        metric               = AddMetric( "NonPSThread73ReadyForDispatch", "Non-PS Thread Ready For Dispatch on Slice7 DualSubslice3 Thread Dispatcher",
                          "The percentage of time in which non-PS thread is ready for dispatch on slice7 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice0";
        metric               = AddMetric( "ThreadHeader60ReadyPort3", "Thread Header Ready on Slice6 DualSubslice0 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice0 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 12 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xfc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice1";
        metric               = AddMetric( "ThreadHeader61ReadyPort3", "Thread Header Ready on Slice6 DualSubslice1 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice1 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 13 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1b0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice2";
        metric               = AddMetric( "ThreadHeader62ReadyPort3", "Thread Header Ready on Slice6 DualSubslice2 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice2 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 14 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a8" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice3";
        metric               = AddMetric( "ThreadHeader63ReadyPort3", "Thread Header Ready on Slice6 DualSubslice3 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice6 dualsubslice3 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 15 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xf0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x1a0" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice0";
        metric               = AddMetric( "ThreadHeader70ReadyPort3", "Thread Header Ready on Slice7 DualSubslice0 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice0 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 16 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xec" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x198" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice1";
        metric               = AddMetric( "ThreadHeader71ReadyPort3", "Thread Header Ready on Slice7 DualSubslice1 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice1 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 17 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x190" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice2";
        metric               = AddMetric( "ThreadHeader72ReadyPort3", "Thread Header Ready on Slice7 DualSubslice2 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice2 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 18 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x188" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice3";
        metric               = AddMetric( "ThreadHeader73ReadyPort3", "Thread Header Ready on Slice7 DualSubslice3 Thread Dispatcher Port 3",
                          "The percentage of time in which thread header is ready on slice7 dualsubslice3 thread dispatcher port 3",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 19 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xe0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x180" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28827360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28a27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28c27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28e27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29827360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29a27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29c27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29e27360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16820e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02834000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02844000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02854000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08a20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16a20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a30004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a31000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02a51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ac20035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14c20e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c30400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ae20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14e20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e30040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e30100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e40040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e40100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e50040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e50100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0d820035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13820e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01830100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03830040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01840100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03840040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03850040, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0da20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13a20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a30400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a30010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a40400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a40010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a50400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a50010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fc20035, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c20e40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c31000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c41000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01c51000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20440, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fe20d40, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11e20039, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e34000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e30001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e44000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e40001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01e54000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e50001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001b0ff0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aa38, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02062caa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00071008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085597, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0208d655, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00194ff2, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baa04, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020b10aa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a2004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01063800, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0306002c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01070180, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01089700, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030800d6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190420, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b0400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0010, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0240, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010c1000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0004, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0001aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0201aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c031926, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030d06, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030020, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a031903, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffe, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fffd, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000fffb, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000fff7, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000ffef, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000ffdf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000ffbf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00000002, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x0000ff7f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_13MetricSet::CTDL_13MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_13MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice0";
        metric               = AddMetric( "PSThread00ReadyForDispatch", "PS Thread Ready For Dispatch on Slice0 Dualsubslice0 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice0 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice1";
        metric               = AddMetric( "PSThread01ReadyForDispatch", "PS Thread Ready For Dispatch on Slice0 Dualsubslice1 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice0 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice2";
        metric               = AddMetric( "PSThread02ReadyForDispatch", "PS Thread Ready For Dispatch on Slice0 Dualsubslice2 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice0 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice3";
        metric               = AddMetric( "PSThread03ReadyForDispatch", "PS Thread Ready For Dispatch on Slice0 Dualsubslice3 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice0 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice0";
        metric               = AddMetric( "PSThread10ReadyForDispatch", "PS Thread Ready For Dispatch on Slice1 Dualsubslice0 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice1 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice1";
        metric               = AddMetric( "PSThread11ReadyForDispatch", "PS Thread Ready For Dispatch on Slice1 Dualsubslice1 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice1 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice2";
        metric               = AddMetric( "PSThread12ReadyForDispatch", "PS Thread Ready For Dispatch on Slice1 Dualsubslice2 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice1 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice3";
        metric               = AddMetric( "PSThread13ReadyForDispatch", "PS Thread Ready For Dispatch on Slice1 Dualsubslice3 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice1 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0aa20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a30050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0cc20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ee20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e35000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e45000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03830005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03840005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13a20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a30050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a40050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15c20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17e20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e35000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e45000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bff00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000700c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ff0c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0107c000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a3000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030360, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c036d08, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e034a52, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50033412, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x520301a0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54031209, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffc, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fff3, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000ffcf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000ff3f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000fcff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000f3ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000cfff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x00003fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_14MetricSet::CTDL_14MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_14MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice0";
        metric               = AddMetric( "PSThread20ReadyForDispatch", "PS Thread Ready For Dispatch on Slice2 Dualsubslice0 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice2 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice1";
        metric               = AddMetric( "PSThread21ReadyForDispatch", "PS Thread Ready For Dispatch on Slice2 Dualsubslice1 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice2 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice2";
        metric               = AddMetric( "PSThread22ReadyForDispatch", "PS Thread Ready For Dispatch on Slice2 Dualsubslice2 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice2 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice3";
        metric               = AddMetric( "PSThread23ReadyForDispatch", "PS Thread Ready For Dispatch on Slice2 Dualsubslice3 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice2 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice0";
        metric               = AddMetric( "PSThread30ReadyForDispatch", "PS Thread Ready For Dispatch on Slice3 Dualsubslice0 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice3 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice1";
        metric               = AddMetric( "PSThread31ReadyForDispatch", "PS Thread Ready For Dispatch on Slice3 Dualsubslice1 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice3 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice2";
        metric               = AddMetric( "PSThread32ReadyForDispatch", "PS Thread Ready For Dispatch on Slice3 Dualsubslice2 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice3 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice3";
        metric               = AddMetric( "PSThread33ReadyForDispatch", "PS Thread Ready For Dispatch on Slice3 Dualsubslice3 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice3 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000d, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0aa20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01230050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0cc20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ee20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e35000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e45000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03830005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03840005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13a20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a30050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a40050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15c20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17e20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e35000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e45000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bff00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000700c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ff0c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0107c000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a3000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0002aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0202aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c032442, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e0318c6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50031006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030603, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffc, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fff3, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000ffcf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000ff3f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000fcff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000f3ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000cfff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x00003fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_15MetricSet::CTDL_15MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_15MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice0";
        metric               = AddMetric( "PSThread40ReadyForDispatch", "PS Thread Ready For Dispatch on Slice4 Dualsubslice0 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice4 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice1";
        metric               = AddMetric( "PSThread41ReadyForDispatch", "PS Thread Ready For Dispatch on Slice4 Dualsubslice1 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice4 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice2";
        metric               = AddMetric( "PSThread42ReadyForDispatch", "PS Thread Ready For Dispatch on Slice4 Dualsubslice2 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice4 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice3";
        metric               = AddMetric( "PSThread43ReadyForDispatch", "PS Thread Ready For Dispatch on Slice4 Dualsubslice3 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice4 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice0";
        metric               = AddMetric( "PSThread50ReadyForDispatch", "PS Thread Ready For Dispatch on Slice5 Dualsubslice0 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice5 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice1";
        metric               = AddMetric( "PSThread51ReadyForDispatch", "PS Thread Ready For Dispatch on Slice5 Dualsubslice1 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice5 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice2";
        metric               = AddMetric( "PSThread52ReadyForDispatch", "PS Thread Ready For Dispatch on Slice5 Dualsubslice2 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice5 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice3";
        metric               = AddMetric( "PSThread53ReadyForDispatch", "PS Thread Ready For Dispatch on Slice5 Dualsubslice3 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice5 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0aa20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a30050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0cc20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ee20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e35000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e45000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03830005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03840005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13a20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a30050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a40050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15c20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17e20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e35000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e45000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bff00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000700c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ff0c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0107c000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a3000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0004ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c032442, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e0318c6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50031006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030603, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffc, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fff3, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000ffcf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000ff3f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000fcff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000f3ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000cfff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x00003fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_16MetricSet::CTDL_16MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_16MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice0";
        metric               = AddMetric( "PSThread60ReadyForDispatch", "PS Thread Ready For Dispatch on Slice6 Dualsubslice0 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice6 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice1";
        metric               = AddMetric( "PSThread61ReadyForDispatch", "PS Thread Ready For Dispatch on Slice6 Dualsubslice1 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice6 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice2";
        metric               = AddMetric( "PSThread62ReadyForDispatch", "PS Thread Ready For Dispatch on Slice6 Dualsubslice2 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice6 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice3";
        metric               = AddMetric( "PSThread63ReadyForDispatch", "PS Thread Ready For Dispatch on Slice6 Dualsubslice3 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice6 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice0";
        metric               = AddMetric( "PSThread70ReadyForDispatch", "PS Thread Ready For Dispatch on Slice7 Dualsubslice0 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice7 dualsubslice0 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 8 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x160" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice1";
        metric               = AddMetric( "PSThread71ReadyForDispatch", "PS Thread Ready For Dispatch on Slice7 Dualsubslice1 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice7 dualsubslice1 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 9 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x168" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice2";
        metric               = AddMetric( "PSThread72ReadyForDispatch", "PS Thread Ready For Dispatch on Slice7 Dualsubslice2 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice7 dualsubslice2 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 10 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xd8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x170" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice3";
        metric               = AddMetric( "PSThread73ReadyForDispatch", "PS Thread Ready For Dispatch on Slice7 Dualsubslice3 Thread Dispatcher",
                          "The percentage of time in which PS thread is ready for dispatch on slice7 dualsubslice3 thread dispatcher",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_TIER_3 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, "PS|FS", nullptr, 11 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xdc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x178" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0aa20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a30050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a40050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0cc20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c30500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c40500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ee20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e35000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e45000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03830005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03840005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03850005, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13a20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a30050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a40050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03a50050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15c20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20007, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17e20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e35000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e45000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e55000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bff00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000700c0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0008a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ff0c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0030, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03060fa0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0107c000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308a55f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01190c00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030b0050, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a3000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0001aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0201aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c032442, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e0318c6, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50031006, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030080, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030603, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fffc, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000fff3, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000ffcf, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x0000ff3f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd960, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd964, 0x0000fcff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd968, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd96c, 0x0000f3ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd970, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd974, 0x0000cfff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd978, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd97c, 0x00003fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_17MetricSet::CTDL_17MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_17MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice0";
        metric               = AddMetric( "Tdl00InputAvailable", "Tdl00 Input Available",
                          "The percentage of time when Tdl00 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice1";
        metric               = AddMetric( "Tdl01InputAvailable", "Tdl01 Input Available",
                          "The percentage of time when Tdl01 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice2";
        metric               = AddMetric( "Tdl02InputAvailable", "Tdl02 Input Available",
                          "The percentage of time when Tdl02 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice0DualSubslice3";
        metric               = AddMetric( "Tdl03InputAvailable", "Tdl03 Input Available",
                          "The percentage of time when Tdl03 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28821c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28a21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28c21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28e21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ca20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ea20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10c20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12c20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c30055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c40055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c50055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14e20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16e20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aa00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020600ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0007f000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000855ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0208aa55, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001900f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0f00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c032508, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030129, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a032100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fff0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000ff0f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000f0ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x00000fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_18MetricSet::CTDL_18MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_18MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice0";
        metric               = AddMetric( "Tdl10InputAvailable", "Tdl10 Input Available",
                          "The percentage of time when Tdl10 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice1";
        metric               = AddMetric( "Tdl11InputAvailable", "Tdl11 Input Available",
                          "The percentage of time when Tdl11 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice2";
        metric               = AddMetric( "Tdl12InputAvailable", "Tdl12 Input Available",
                          "The percentage of time when Tdl12 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice1DualSubslice3";
        metric               = AddMetric( "Tdl13InputAvailable", "Tdl13 Input Available",
                          "The percentage of time when Tdl13 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000c, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29821c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29a21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29c21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29e21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09820ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01830055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01840055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0da20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fa20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13c20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15e20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17e20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0106aa00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030600ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0107f000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010855ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308aa55, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011900f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0f00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02025555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030120, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c032508, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030129, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a032100, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000008, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fff0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000ff0f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000f0ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x00000fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_19MetricSet::CTDL_19MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_19MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice0";
        metric               = AddMetric( "Tdl20InputAvailable", "Tdl20 Input Available",
                          "The percentage of time when Tdl20 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice1";
        metric               = AddMetric( "Tdl21InputAvailable", "Tdl21 Input Available",
                          "The percentage of time when Tdl21 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice2";
        metric               = AddMetric( "Tdl22InputAvailable", "Tdl22 Input Available",
                          "The percentage of time when Tdl22 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice2DualSubslice3";
        metric               = AddMetric( "Tdl23InputAvailable", "Tdl23 Input Available",
                          "The percentage of time when Tdl23 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000d, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28821c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28a21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28c21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28e21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ca20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ea20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01235500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10c20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12c20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c30055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c40055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c50055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14e20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16e20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aa00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020600ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0007f000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000855ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0208aa55, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001900f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0f00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0002aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0202aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030c42, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030063, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fff0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000ff0f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000f0ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x00000fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_20MetricSet::CTDL_20MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_20MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice0";
        metric               = AddMetric( "Tdl30InputAvailable", "Tdl30 Input Available",
                          "The percentage of time when Tdl30 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice1";
        metric               = AddMetric( "Tdl31InputAvailable", "Tdl31 Input Available",
                          "The percentage of time when Tdl31 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice2";
        metric               = AddMetric( "Tdl32InputAvailable", "Tdl32 Input Available",
                          "The percentage of time when Tdl32 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice3DualSubslice3";
        metric               = AddMetric( "Tdl33InputAvailable", "Tdl33 Input Available",
                          "The percentage of time when Tdl33 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000d, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29821c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29a21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29c21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29e21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09820ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01830055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01840055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0da20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fa20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13c20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15e20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17e20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0106aa00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030600ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0107f000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010855ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308aa55, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011900f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0f00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0002aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0202aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04031249, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030001, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030c42, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030063, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000009, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fff0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000ff0f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000f0ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x00000fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_21MetricSet::CTDL_21MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_21MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice0";
        metric               = AddMetric( "Tdl40InputAvailable", "Tdl40 Input Available",
                          "The percentage of time when Tdl40 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice1";
        metric               = AddMetric( "Tdl41InputAvailable", "Tdl41 Input Available",
                          "The percentage of time when Tdl41 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice2";
        metric               = AddMetric( "Tdl42InputAvailable", "Tdl42 Input Available",
                          "The percentage of time when Tdl42 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice4DualSubslice3";
        metric               = AddMetric( "Tdl43InputAvailable", "Tdl43 Input Available",
                          "The percentage of time when Tdl43 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28821c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28a21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28c21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28e21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ca20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ea20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10c20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12c20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c30055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c40055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c50055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14e20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16e20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aa00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020600ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0007f000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000855ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0208aa55, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001900f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0f00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0004ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030c42, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030063, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fff0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000ff0f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000f0ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x00000fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_22MetricSet::CTDL_22MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_22MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice0";
        metric               = AddMetric( "Tdl50InputAvailable", "Tdl50 Input Available",
                          "The percentage of time when Tdl50 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice1";
        metric               = AddMetric( "Tdl51InputAvailable", "Tdl51 Input Available",
                          "The percentage of time when Tdl51 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice2";
        metric               = AddMetric( "Tdl52InputAvailable", "Tdl52 Input Available",
                          "The percentage of time when Tdl52 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice5DualSubslice3";
        metric               = AddMetric( "Tdl53InputAvailable", "Tdl53 Input Available",
                          "The percentage of time when Tdl53 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000e, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29821c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29a21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29c21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29e21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09820ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01830055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01840055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0da20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fa20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13c20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15e20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17e20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0106aa00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030600ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0107f000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010855ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308aa55, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011900f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0f00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02015555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0004ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030c42, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030063, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000a, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fff0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000ff0f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000f0ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x00000fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_23MetricSet::CTDL_23MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_23MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice0";
        metric               = AddMetric( "Tdl60InputAvailable", "Tdl60 Input Available",
                          "The percentage of time when Tdl60 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice1";
        metric               = AddMetric( "Tdl61InputAvailable", "Tdl61 Input Available",
                          "The percentage of time when Tdl61 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice2";
        metric               = AddMetric( "Tdl62InputAvailable", "Tdl62 Input Available",
                          "The percentage of time when Tdl62 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice6DualSubslice3";
        metric               = AddMetric( "Tdl63InputAvailable", "Tdl63 Input Available",
                          "The percentage of time when Tdl63 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28821c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28a21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28c21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28e21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06820447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x08820ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0a820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00830055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00840055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00850055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06a20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ca20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0ea20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00a55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06c20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x10c20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x12c20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c30055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c40055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02c50055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06e20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x14e20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16e20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02e55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aa00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020600ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0007f000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000855ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0208aa55, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001900f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000b5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001a0f00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020c0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0001aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0201aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030c42, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030063, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fff0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000ff0f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000f0ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x00000fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
    CTDL_24MetricSet::CTDL_24MetricSet( CMetricsDevice* device, CConcurrentGroup* concurrentGroup, const char* symbolicName, const char* shortName, uint32_t apiMask, uint32_t category, uint32_t snapshotReportSize, uint32_t deltaReportSize, TReportType reportType, TByteArrayLatest* platformMask, uint32_t gtMask /*= GT_TYPE_ALL*/, bool isCustom /*= false*/ )
        : CMetricSet( device, concurrentGroup, symbolicName, shortName, apiMask, category, snapshotReportSize, deltaReportSize, reportType, platformMask, gtMask, isCustom )
    {
    }
    TCompletionCode CTDL_24MetricSet::Initialize()
    {
        TCompletionCode ret                  = CC_OK;
        CMetric*        metric               = nullptr;
        CInformation*   information          = nullptr;
        const char*     availabilityEquation = nullptr;
        m_params_1_0.InformationCount        = m_concurrentGroup->GetInformationCount();
        MD_CHECK_CC( SetApiSpecificId( "GPAV", 0, 0x40000000, 0x80000203, 0, 0, "Intel Performance Counters for GT Set Dynamic", 0, "Intel_Raw_Hardware_Counters_Set_0_Query", 0 ) );

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuTime", "GPU Time Elapsed",
                          "Time elapsed on the GPU during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_UINT64, "ns", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 0 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x04 1000000000 UMUL $GpuTimestampFrequency UDIV" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x00" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "NS_TIME" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuCoreClocks", "GPU Core Clocks",
                          "The total number of GPU core clocks elapsed during the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "cycles", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 1 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x0c" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x08" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "AvgGpuCoreFrequencyMHz", "AVG GPU Core Frequency",
                          "Average GPU Core Frequency in the measurement.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_EVENT, RESULT_UINT64, "MHz", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 2 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "$GpuCoreClocks 1000 UMUL $$GpuTime UDIV" ) ) );
        }

        availabilityEquation = nullptr;
        metric               = AddMetric( "GpuBusy", "GPU Busy",
                          "The percentage of time in which the GPU has been processing GPU commands.",
                          "GPU", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ), USAGE_FLAG_TIER_1 | USAGE_FLAG_OVERVIEW | USAGE_FLAG_SYSTEM | USAGE_FLAG_FRAME, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_GPU, availabilityEquation, nullptr, "oa.fixed", 3 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x10" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice0";
        metric               = AddMetric( "Tdl70InputAvailable", "Tdl70 Input Available",
                          "The percentage of time when Tdl70 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 4 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc0" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x140" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice1";
        metric               = AddMetric( "Tdl71InputAvailable", "Tdl71 Input Available",
                          "The percentage of time when Tdl71 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 5 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc4" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x148" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice2";
        metric               = AddMetric( "Tdl72InputAvailable", "Tdl72 Input Available",
                          "The percentage of time when Tdl72 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 6 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xc8" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x150" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = "$GtSlice7DualSubslice3";
        metric               = AddMetric( "Tdl73InputAvailable", "Tdl73 Input Available",
                          "The percentage of time when Tdl73 input is available",
                          "GPU/Thread Dispatcher", ( METRIC_GROUP_NAME_ID_GPU * 0x1000000 ) | ( METRIC_GROUP_NAME_ID_TD * 0x10000 ), USAGE_FLAG_FRAME | USAGE_FLAG_BATCH | USAGE_FLAG_DRAW, API_TYPE_DX9 | API_TYPE_DX10 | API_TYPE_DX11 | API_TYPE_DX12 | API_TYPE_VULKAN | API_TYPE_OGL | API_TYPE_OGL4_X | API_TYPE_OCL | API_TYPE_MEDIA | API_TYPE_IOSTREAM,
                          METRIC_TYPE_DURATION, RESULT_FLOAT, "percent", 0, 0, HW_UNIT_DUALSUBSLICE, availabilityEquation, nullptr, nullptr, 7 );
        if( metric )
        {
            MD_CHECK_CC( ( metric->SetSnapshotReportReadEquation( "dw@0xcc" ) ) );
            MD_CHECK_CC( ( metric->SetDeltaReportReadEquation( "qw@0x158" ) ) );
            MD_CHECK_CC( ( metric->SetNormalizationEquation( "GpuDuration" ) ) );
            MD_CHECK_CC( ( metric->SetSnapshotReportDeltaFunction( "DELTA 32" ) ) );
            MD_CHECK_CC( ( metric->SetMaxValueEquation( "100" ) ) );
        }

        availabilityEquation = nullptr;
        if( AddStartRegisterSet( 0, 0, availabilityEquation ) == CC_OK )
        {
            AddStartConfigRegister( 0x0d04, 0x00000200, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000f, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27826400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29821c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27a26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29a21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27c26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29c21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x27e26400, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x29e21c80, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07820447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x09820ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0b820966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01820000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01830055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01840055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01850055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07a20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0da20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0fa20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x01a55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07c20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x11c20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x13c20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c30055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c40055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03c50055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x07e20447, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x15e20ff1, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x17e20966, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x05e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e20000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e35500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e45500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x03e55500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x001bffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0006aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0206aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02085555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0019ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x000baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x020baaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0106aa00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030600ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0107f000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010855ff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0308aa55, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030a5555, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011900f0, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x010b5500, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x011a0f00, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x030c0055, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0001aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0201aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x00032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x02032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x04032492, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x06030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x16030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x48030060, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x26030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4c030c42, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x28030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4e030063, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x34030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x3a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x40030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x50030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x52030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x54030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x18030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1a030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x4a030840, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1c030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x1e030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x22030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x24030000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x0000000b, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0011aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0211aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0012ffff, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0013aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x0213aaaa, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9884, 0x00000000, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0x9888, 0x66030002, REGISTER_TYPE_NOA );
            AddStartConfigRegister( 0xd900, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd904, 0xf0800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd910, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd914, 0x00800000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd920, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd940, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd944, 0x0000fff0, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd948, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd94c, 0x0000ff0f, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd950, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd954, 0x0000f0ff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd958, 0x00000000, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0xd95c, 0x00000fff, REGISTER_TYPE_OA );
            AddStartConfigRegister( 0x2b2c, 0x00000000, REGISTER_TYPE_OA );
        }
        RefreshConfigRegisters();
        return CC_OK;

    exception:
        return ret;
    }
} // namespace MetricsDiscoveryInternal::MetricSets_XEHP_SDV_GT1_GT2_OA

#endif
